CCS PCH C Compiler, Version 4.104, 5967               05-Sept.-16 07:56

               Filename: H:\JP\JP\Laboratorio\Autoclave\Autoclave Horizontal\Sin Precamara\2015\Autoclaves Mayaguez\Ajustes Autoclaves Mayaguez\JPA23LH\Firmware V3\Hardware_Controller\Hardware_Controller.lst

               ROM used: 13650 bytes (42%)
                         Largest free fragment is 19118
               RAM used: 955 (47%) at main() level
                         995 (49%) worst case
               Stack:    13 worst case (4 in main + 9 for interrupts)

*
0000:  GOTO   23B6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0EF8
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   0F7A
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0DEA
006C:  BTFSS  FA0.5
006E:  GOTO   0078
0072:  BTFSC  FA1.5
0074:  GOTO   0CEA
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... // Cuatro pulsadores de entrada (Derecha, Izquierda, arriba y abajo). 
.................... // Reloj con XT de 4 MHz. 
.................... // Programación para Autoclave 
.................... // Tiene Menú:Ciclo: Liquidos, Instrumental suave, Textil Instrumental y Caucho. 
.................... // Tiene 6 niveles programables para desfogue suave. 
.................... // Ing. Juan David Piñeros. 
.................... // JP Inglobal. 2015 
....................  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL1,CPUDIV1,VREGEN,NOMCLR// PLL1 para 4 MHz 
.................... //#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL3,CPUDIV4,VREGEN,NOMCLR// PLL1 para 12 MHz 
.................... #use delay(clock=48000000) 
*
0FDE:  MOVLW  02
0FE0:  MOVWF  FEA
0FE2:  MOVLW  F0
0FE4:  MOVWF  FE9
0FE6:  MOVF   FEF,W
0FE8:  BZ    1006
0FEA:  MOVLW  0F
0FEC:  MOVWF  01
0FEE:  CLRF   00
0FF0:  DECFSZ 00,F
0FF2:  BRA    0FF0
0FF4:  DECFSZ 01,F
0FF6:  BRA    0FEE
0FF8:  MOVLW  8F
0FFA:  MOVWF  00
0FFC:  DECFSZ 00,F
0FFE:  BRA    0FFC
1000:  NOP   
1002:  DECFSZ FEF,F
1004:  BRA    0FEA
1006:  RETLW  00
.................... #use RS232(BAUD=2400, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
*
114E:  BTFSS  F9E.4
1150:  BRA    114E
1152:  MOVWF  FAD
1154:  GOTO   11EA (RETURN)
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0D72:  MOVLB  3
0D74:  MOVFF  304,FE9
0D78:  MOVFF  305,FEA
0D7C:  MOVFF  FEF,308
0D80:  MOVFF  307,03
0D84:  MOVFF  306,FE9
0D88:  MOVFF  307,FEA
0D8C:  MOVF   FEF,W
0D8E:  SUBWF  x08,W
0D90:  BNZ   0DBC
....................       if (*s1 == '\0') 
0D92:  MOVFF  305,03
0D96:  MOVFF  304,FE9
0D9A:  MOVFF  03,FEA
0D9E:  MOVF   FEF,F
0DA0:  BNZ   0DA8
....................          return(0); 
0DA2:  MOVLW  00
0DA4:  MOVWF  01
0DA6:  BRA    0DE6
0DA8:  MOVFF  305,03
0DAC:  MOVF   x04,W
0DAE:  INCF   x04,F
0DB0:  BTFSC  FD8.2
0DB2:  INCF   x05,F
0DB4:  INCF   x06,F
0DB6:  BTFSC  FD8.2
0DB8:  INCF   x07,F
0DBA:  BRA    0D74
....................    return((*s1 < *s2) ? -1: 1); 
0DBC:  MOVFF  305,03
0DC0:  MOVFF  304,FE9
0DC4:  MOVFF  305,FEA
0DC8:  MOVFF  FEF,308
0DCC:  MOVFF  307,03
0DD0:  MOVFF  306,FE9
0DD4:  MOVFF  307,FEA
0DD8:  MOVF   FEF,W
0DDA:  SUBWF  x08,W
0DDC:  BC    0DE2
0DDE:  MOVLW  FF
0DE0:  BRA    0DE4
0DE2:  MOVLW  01
0DE4:  MOVWF  01
.................... } 
0DE6:  MOVLB  0
0DE8:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Definición de Entradas 
.................... #define   TERM          !input(PIN_D6) 
.................... #define   DOOR          !input(PIN_D5) 
.................... #define   STOP          !input(PIN_D4) 
.................... #define   LEVELT        !input(PIN_D0) 
.................... #define   LEVELR        !input(PIN_D1) 
....................  
.................... // Definición de Salidas 
.................... #define   Resistencia_on     output_bit(PIN_B0,1) 
.................... #define   Resistencia_off    output_bit(PIN_B0,0) 
.................... #define   EV_Desfogue_on     output_bit(PIN_B1,1) 
.................... #define   EV_Desfogue_off    output_bit(PIN_B1,0) 
.................... #define   EV_Trampa_on       output_bit(PIN_B3,1) 
.................... #define   EV_Trampa_off      output_bit(PIN_B3,0) 
.................... #define   EV_Agua_on         output_bit(PIN_B2,1) 
.................... #define   EV_Agua_off        output_bit(PIN_B2,0) 
.................... #define   Motor_Puerta_on    output_bit(PIN_B5,1) 
.................... #define   Motor_Puerta_off   output_bit(PIN_B5,0) 
.................... #define   EV_in_Agua_on      output_bit(PIN_B4,1) 
.................... #define   EV_in_Agua_off     output_bit(PIN_B4,0) 
.................... #define   Bomba_Vacio_on     output_bit(PIN_B6,1) 
.................... #define   Bomba_Vacio_off    output_bit(PIN_B6,0) 
.................... #define   Bomba_Agua_on      output_bit(PIN_B7,1) 
.................... #define   Bomba_Agua_off     output_bit(PIN_B7,0) 
....................  
.................... #define USB_HID_DEVICE FALSE // deshabilitamos el uso de las directivas HID 
.................... #define USB_EP1_TX_ENABLE USB_ENABLE_BULK // turn on EP1(EndPoint1) for IN bulk/interrupt transfers 
.................... #define USB_EP1_RX_ENABLE USB_ENABLE_BULK // turn on EP1(EndPoint1) for OUT bulk/interrupt transfers 
.................... #define USB_EP1_TX_SIZE 32 // size to allocate for the tx endpoint 1 buffer 
.................... #define USB_EP1_RX_SIZE 32 // size to allocate for the rx endpoint 1 buffer 
.................... #include <pic18_usb.h> // Microchip PIC18Fxx5x Hardware layer for CCS's PIC USB driver 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
.................... #include "header.h" // Configuración del USB y los descriptores para este dispositivo 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// start config descriptor 
.................... /// right now we only support one configuration descriptor. 
.................... /// the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_TOTAL_CONFIG_LEN 32 //config+interface+class+endpoint 
....................  
.................... //configuration descriptor 
.................... char const USB_CONFIG_DESC[] = { 
.................... //config_descriptor for config index 1 
.................... USB_DESC_CONFIG_LEN, //length of descriptor size 
.................... USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (0x02) 
.................... USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config 
.................... 1, //number of interfaces this device supports 
.................... 0x01, //identifier for this configuration. (IF we had more than one configurations) 
.................... 0x00, //index of string descriptor for this configuration 
.................... 0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 reserved and bit7=1 
.................... 0x32, //maximum bus power required (maximum milliamperes/2) (0x32 = 100mA) 
....................  
.................... //interface descriptor 0 alt 0 
.................... USB_DESC_INTERFACE_LEN, //length of descriptor 
.................... USB_DESC_INTERFACE_TYPE, //constant INTERFACE (0x04) 
.................... 0x00, //number defining this interface (IF we had more than one interface) 
.................... 0x00, //alternate setting 
.................... 2, //number of endpoints, not counting endpoint 0. 
.................... 0xFF, //class code, FF = vendor defined 
.................... 0xFF, //subclass code, FF = vendor 
.................... 0xFF, //protocol code, FF = vendor 
.................... 0x00, //index of string descriptor for interface 
....................  
.................... //endpoint descriptor 
.................... USB_DESC_ENDPOINT_LEN, //length of descriptor 
.................... USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (0x05) 
.................... 0x81, //endpoint number and direction (0x81 = EP1 IN) 
.................... 0x02, //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
.................... USB_EP1_TX_SIZE,0x00, //maximum packet size supported 
.................... 0x01, //polling interval in ms. (for interrupt transfers ONLY) 
....................  
.................... //endpoint descriptor 
.................... USB_DESC_ENDPOINT_LEN, //length of descriptor 
.................... USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (0x05) 
.................... 0x01, //endpoint number and direction (0x01 = EP1 OUT) 
.................... 0x02, //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
.................... USB_EP1_RX_SIZE,0x00, //maximum packet size supported 
.................... 0x01, //polling interval in ms. (for interrupt transfers ONLY) 
....................  
.................... }; 
....................  
.................... //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
.................... //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
.................... // a specific descriptor in the above table. 
....................  
.................... //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
.................... // FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
.................... #define USB_NUM_HID_INTERFACES 0 
....................  
.................... //the maximum number of interfaces seen on any config 
.................... //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
.................... #define USB_MAX_NUM_INTERFACES 1 
....................  
.................... //define how many interfaces there are per config. [0] is the first config, etc. 
.................... const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
.................... #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
.................... #error USB_TOTAL_CONFIG_LEN not defined correctly 
.................... #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //device descriptor 
.................... char const USB_DEVICE_DESC[] ={ 
.................... USB_DESC_DEVICE_LEN, //the length of this report 
.................... 0x01, //constant DEVICE (0x01) 
.................... 0x10,0x01, //usb version in bcd 
.................... 0x00, //class code (if 0, interface defines class. FF is vendor defined) 
.................... 0x00, //subclass code 
.................... 0x00, //protocol code 
.................... USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) 
.................... 0xD8,0x04, //vendor id (0x04D8 is Microchip) 
.................... 0x0B,0x00, //product id 
.................... 0x01,0x00, //device release number 
.................... 0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below) 
.................... 0x02, //index of string descriptor of the product 
.................... 0x00, //index of string descriptor of serial number 
.................... USB_NUM_CONFIGURATIONS //number of possible configurations 
.................... }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// start string descriptors 
.................... /// String 0 is a special language string, and must be defined. People in U.S.A. can leave this alone. 
.................... /// 
.................... /// You must define the length else get_next_string_character() will not see the string 
.................... /// Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string. 
.................... //offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... const char USB_STRING_DESC_OFFSET[]={0,4,20}; 
....................  
.................... #define USB_STRING_DESC_COUNT sizeof(USB_STRING_DESC_OFFSET) 
....................  
.................... char const USB_STRING_DESC[]={ 
.................... //string 0 Codificacion de la tabla ??? 
.................... 4, //length of string index 
.................... USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
.................... 0x09,0x04, //Microsoft Defined for US-English 
.................... //string 1 --> la compañia del producto ??? 
.................... 16, //length of string index 
.................... USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
.................... 'j',0, 
.................... 'P',0, 
.................... 'i',0, 
.................... 'c',0, 
.................... 'U',0, 
.................... 's',0, 
.................... 'b',0, 
.................... //string 2 --> nombre del dispositivo 
.................... 34, //length of string index 
.................... //18, 
.................... USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................  
.................... 'L',0, 
.................... 'e',0, 
.................... 'c',0, 
.................... 't',0, 
.................... 'o',0, 
.................... 'r',0, 
.................... ' ',0, 
.................... 'F',0, 
.................... 'L',0, 
.................... 'U',0, 
.................... 'J',0, 
.................... 'O',0, 
.................... ' ',0, 
.................... 'J',0, 
.................... 'P',0, 
.................... '.',0, 
.................... }; 
.................... #ENDIF     
....................  
.................... #include <usb.c> // handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense (USB_CON_SENSE_PIN) //// 
.................... ////        is not defined the usb_task() assumes that USB is always   //// 
.................... ////        connected.                                                 //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying ot use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
....................  
.................... typedef struct 
.................... { 
....................    int8 stat; 
....................    int8 cnt; 
....................    int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #define debug_putc(c) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... int8 USTATCopy; 
....................  
.................... int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBRAM.bd[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBRAM.bd[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBRAM.bd[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBRAM.bd[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBRAM.bd[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBRAM.bd[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
*
1A70:  CLRF   03
1A72:  MOVLB  2
1A74:  MOVF   xEA,W
1A76:  ADDLW  70
1A78:  MOVWF  FE9
1A7A:  MOVLW  0F
1A7C:  ADDWFC 03,W
1A7E:  MOVWF  FEA
1A80:  MOVF   FEF,F
1A82:  BZ    1A9E
1A84:  MOVF   xEA,W
1A86:  MULLW  08
1A88:  MOVF   FF3,W
1A8A:  CLRF   xEC
1A8C:  MOVWF  xEB
1A8E:  MOVWF  FE9
1A90:  MOVLW  04
1A92:  ADDWF  xEC,W
1A94:  MOVWF  FEA
1A96:  MOVFF  FEF,2EB
1A9A:  BTFSS  xEB.7
1A9C:  BRA    1AA2
1A9E:  MOVLW  00
1AA0:  BRA    1AA4
1AA2:  MOVLW  01
1AA4:  MOVWF  01
.................... } 
1AA6:  MOVLB  0
1AA8:  GOTO   2AE2 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
09FC:  CLRF   03
09FE:  MOVLB  3
0A00:  MOVF   x0B,W
0A02:  ADDLW  70
0A04:  MOVWF  FE9
0A06:  MOVLW  0F
0A08:  ADDWFC 03,W
0A0A:  MOVWF  FEA
0A0C:  MOVF   FEF,F
0A0E:  BZ    0A34
0A10:  MOVF   x0B,W
0A12:  MULLW  08
0A14:  MOVF   FF3,W
0A16:  CLRF   x0D
0A18:  MOVWF  x0C
0A1A:  MOVLW  04
0A1C:  ADDWF  x0C,F
0A1E:  MOVLW  00
0A20:  ADDWFC x0D,F
0A22:  MOVFF  30C,FE9
0A26:  MOVLW  04
0A28:  ADDWF  x0D,W
0A2A:  MOVWF  FEA
0A2C:  MOVFF  FEF,30C
0A30:  BTFSS  x0C.7
0A32:  BRA    0A38
0A34:  MOVLW  00
0A36:  BRA    0A3A
0A38:  MOVLW  01
0A3A:  MOVWF  01
.................... } 
0A3C:  MOVLB  0
0A3E:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
1092:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1094:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1096:  MOVLW  08
1098:  MOVWF  F6F
....................     
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); 
109A:  MOVF   F94,W
109C:  IORLW  30
109E:  MOVLB  2
10A0:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
10A2:  CLRF   22
10A4:  CLRF   16
10A6:  BTFSC  FF2.7
10A8:  BSF    16.7
10AA:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
10AC:  MOVLB  0
10AE:  CALL   02F6
10B2:  BTFSC  16.7
10B4:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
10B6:  GOTO   10BC (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
10C0:  CLRF   16
10C2:  BTFSC  FF2.7
10C4:  BSF    16.7
10C6:  BCF    FF2.7
....................    usb_token_reset(); 
10C8:  CALL   02F6
10CC:  BTFSC  16.7
10CE:  BSF    FF2.7
....................    UCON = 0; 
10D0:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
10D2:  MOVLW  14
10D4:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
10D6:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
10D8:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
10DA:  MOVLW  01
10DC:  MOVWF  22
.................... } 
10DE:  GOTO   10E8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
10BA:  BRA    1092
.................... } 
10BC:  GOTO   1106 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
10E2:  BTFSC  F6D.3
10E4:  BRA    10E8
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
10E6:  BRA    10C0
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
10E8:  DECFSZ 22,W
10EA:  BRA    1102
10EC:  BTFSC  F6D.5
10EE:  BRA    1102
....................    { 
....................       UIR=0; 
10F0:  CLRF   F68
....................       UIE=0; 
10F2:  CLRF   F69
....................       enable_interrupts(INT_USB); 
10F4:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
10F6:  MOVLW  C0
10F8:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
10FA:  MOVLW  11
10FC:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
10FE:  MOVLW  02
1100:  MOVWF  22
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1102:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
1104:  BRA    10BA
....................  
....................    do  
....................    { 
....................       usb_task(); 
1106:  RCALL  10E2
....................    } while (usb_state != USB_STATE_POWERED); 
1108:  MOVF   22,W
110A:  SUBLW  02
110C:  BNZ   1106
.................... } 
110E:  GOTO   2A48 (RETURN)
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0A40:  MOVFF  306,30B
0A44:  RCALL  09FC
0A46:  MOVF   01,F
0A48:  BZ    0B12
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0A4A:  MOVLB  3
0A4C:  MOVF   x06,W
0A4E:  MULLW  08
0A50:  MOVF   FF3,W
0A52:  CLRF   x0C
0A54:  MOVWF  x0B
0A56:  MOVLW  04
0A58:  ADDWF  x0B,F
0A5A:  MOVLW  00
0A5C:  ADDWFC x0C,F
0A5E:  MOVLW  01
0A60:  ADDWF  x0B,W
0A62:  MOVWF  01
0A64:  MOVLW  00
0A66:  ADDWFC x0C,W
0A68:  MOVWF  03
0A6A:  MOVFF  01,FE9
0A6E:  MOVLW  04
0A70:  ADDWF  03,W
0A72:  MOVWF  FEA
0A74:  MOVFF  307,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0A78:  MOVF   x09,W
0A7A:  SUBLW  02
0A7C:  BNZ   0AAC
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0A7E:  MOVF   x06,W
0A80:  MULLW  08
0A82:  MOVF   FF3,W
0A84:  CLRF   x0C
0A86:  MOVWF  x0B
0A88:  MOVLW  04
0A8A:  ADDWF  x0B,F
0A8C:  MOVLW  00
0A8E:  ADDWFC x0C,F
0A90:  MOVFF  30B,FE9
0A94:  MOVLW  04
0A96:  ADDWF  x0C,W
0A98:  MOVWF  FEA
0A9A:  MOVFF  FEF,30A
....................          if (bit_test(i,6)) 
0A9E:  BTFSS  x0A.6
0AA0:  BRA    0AA6
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0AA2:  CLRF   x09
....................          else 
0AA4:  BRA    0AAA
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0AA6:  MOVLW  01
0AA8:  MOVWF  x09
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0AAA:  BRA    0AD2
0AAC:  MOVF   x09,W
0AAE:  SUBLW  04
0AB0:  BNZ   0AD2
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0AB2:  MOVF   x06,W
0AB4:  MULLW  08
0AB6:  MOVF   FF3,W
0AB8:  CLRF   x0C
0ABA:  MOVWF  FE9
0ABC:  MOVLW  04
0ABE:  ADDWF  x0C,W
0AC0:  MOVWF  FEA
0AC2:  MOVFF  FEF,30A
....................          if (bit_test(i,6)) 
0AC6:  BTFSS  x0A.6
0AC8:  BRA    0AD0
....................             tgl = USB_DTS_DATA1; 
0ACA:  MOVLW  01
0ACC:  MOVWF  x09
....................          else 
0ACE:  BRA    0AD2
....................             tgl = USB_DTS_DATA0; 
0AD0:  CLRF   x09
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0AD2:  DECFSZ x09,W
0AD4:  BRA    0ADC
....................          i=0xC8;  //DATA1, UOWN 
0AD6:  MOVLW  C8
0AD8:  MOVWF  x0A
....................       else //if (tgl == USB_DTS_DATA0)  
0ADA:  BRA    0AE0
....................          i=0x88; //DATA0, UOWN 
0ADC:  MOVLW  88
0ADE:  MOVWF  x0A
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0AE0:  BTFSC  x08.0
0AE2:  BSF    x0A.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0AE4:  BTFSC  x08.1
0AE6:  BSF    x0A.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0AE8:  MOVF   x06,W
0AEA:  MULLW  08
0AEC:  MOVF   FF3,W
0AEE:  CLRF   x0C
0AF0:  MOVWF  x0B
0AF2:  MOVLW  04
0AF4:  ADDWF  x0B,F
0AF6:  MOVLW  00
0AF8:  ADDWFC x0C,F
0AFA:  MOVFF  30B,FE9
0AFE:  MOVLW  04
0B00:  ADDWF  x0C,W
0B02:  MOVWF  FEA
0B04:  MOVFF  30A,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0B08:  MOVLW  01
0B0A:  MOVWF  01
0B0C:  BRA    0B18
....................    } 
....................    else  
0B0E:  BRA    0B10
0B10:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0B12:  MOVLW  00
0B14:  MOVWF  01
0B16:  MOVLB  3
.................... } 
0B18:  MOVLB  0
0B1A:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl)  
.................... { 
*
1CB6:  CLRF   16
1CB8:  BTFSC  FF2.7
1CBA:  BSF    16.7
1CBC:  BCF    FF2.7
....................    int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
1CBE:  MOVFF  2EA,30B
1CC2:  CALL   09FC
1CC6:  BTFSC  16.7
1CC8:  BSF    FF2.7
1CCA:  MOVF   01,F
1CCC:  BZ    1D5E
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
1CCE:  MOVLB  2
1CD0:  MOVF   xEA,W
1CD2:  MULLW  08
1CD4:  MOVF   FF3,W
1CD6:  CLRF   xF3
1CD8:  MOVWF  xF2
1CDA:  MOVLW  04
1CDC:  ADDWF  xF2,F
1CDE:  MOVLW  00
1CE0:  ADDWFC xF3,F
1CE2:  MOVLW  02
1CE4:  ADDWF  xF2,W
1CE6:  MOVWF  01
1CE8:  MOVLW  00
1CEA:  ADDWFC xF3,W
1CEC:  MOVWF  03
1CEE:  MOVFF  01,FE9
1CF2:  MOVLW  04
1CF4:  ADDWF  03,W
1CF6:  MOVWF  FEA
1CF8:  MOVFF  FEC,03
1CFC:  MOVF   FED,F
1CFE:  MOVFF  FEF,2F0
1D02:  MOVFF  03,2F1
....................       memcpy(buff_add, ptr, len);      
1D06:  MOVFF  2F1,FEA
1D0A:  MOVFF  2F0,FE9
1D0E:  MOVFF  2EC,FE2
1D12:  MOVFF  2EB,FE1
1D16:  MOVFF  2EE,02
1D1A:  MOVFF  2ED,01
1D1E:  MOVF   01,F
1D20:  BZ    1D26
1D22:  INCF   02,F
1D24:  BRA    1D2A
1D26:  MOVF   02,F
1D28:  BZ    1D36
1D2A:  MOVFF  FE6,FEE
1D2E:  DECFSZ 01,F
1D30:  BRA    1D2A
1D32:  DECFSZ 02,F
1D34:  BRA    1D2A
1D36:  CLRF   16
1D38:  BTFSC  FF2.7
1D3A:  BSF    16.7
1D3C:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
1D3E:  MOVFF  2EA,306
1D42:  MOVFF  2EE,308
1D46:  MOVFF  2ED,307
1D4A:  MOVFF  2EF,309
1D4E:  MOVLB  0
1D50:  CALL   0A40
1D54:  BTFSC  16.7
1D56:  BSF    FF2.7
1D58:  MOVF   01,W
1D5A:  BRA    1D62
....................    } 
....................    else  
1D5C:  BRA    1D5E
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
1D5E:  MOVLW  00
1D60:  MOVWF  01
.................... } 
1D62:  GOTO   3212 (RETURN)
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    int8 i; 
....................    int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0932:  MOVLB  3
0934:  MOVF   x06,W
0936:  MULLW  08
0938:  MOVF   FF3,W
093A:  CLRF   x0C
093C:  MOVWF  FE9
093E:  MOVLW  04
0940:  ADDWF  x0C,W
0942:  MOVWF  FEA
0944:  MOVFF  FEF,308
....................    if (tgl == USB_DTS_TOGGLE)  
0948:  MOVF   x07,W
094A:  SUBLW  02
094C:  BNZ   095A
....................    { 
....................       if (bit_test(i,6)) 
094E:  BTFSS  x08.6
0950:  BRA    0956
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0952:  CLRF   x07
....................       else 
0954:  BRA    095A
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0956:  MOVLW  01
0958:  MOVWF  x07
....................    } 
....................    if (tgl == USB_DTS_STALL)  
095A:  MOVF   x07,W
095C:  SUBLW  03
095E:  BNZ   0986
....................    { 
....................       i = 0x84; 
0960:  MOVLW  84
0962:  MOVWF  x08
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0964:  MOVF   x06,W
0966:  MULLW  08
0968:  MOVF   FF3,W
096A:  CLRF   x0C
096C:  MOVWF  x0B
096E:  MOVLW  04
0970:  ADDWF  x0B,F
0972:  MOVLW  00
0974:  ADDWFC x0C,F
0976:  MOVFF  30B,FE9
097A:  MOVLW  04
097C:  ADDWF  x0C,W
097E:  MOVWF  FEA
0980:  MOVLW  84
0982:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0984:  BRA    0994
0986:  DECFSZ x07,W
0988:  BRA    0990
....................       i = 0xC8;  //DATA1, UOWN 
098A:  MOVLW  C8
098C:  MOVWF  x08
....................    else //if (tgl == USB_DTS_DATA0)  
098E:  BRA    0994
....................       i = 0x88; //DATA0, UOWN 
0990:  MOVLW  88
0992:  MOVWF  x08
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0994:  BCF    FD8.0
0996:  RLCF   x06,W
0998:  CLRF   03
099A:  MOVFF  FF2,30B
099E:  BCF    FF2.7
09A0:  MOVLB  0
09A2:  CALL   00DA
09A6:  TBLRD*+
09A8:  MOVFF  FF5,03
09AC:  MOVLB  3
09AE:  BTFSC  x0B.7
09B0:  BSF    FF2.7
09B2:  MOVWF  x09
09B4:  MOVFF  03,30A
....................    EP_BDxCNT_O(endpoint) = len; 
09B8:  MOVF   x06,W
09BA:  MULLW  08
09BC:  MOVF   FF3,W
09BE:  CLRF   x0C
09C0:  MOVWF  x0B
09C2:  MOVLW  01
09C4:  ADDWF  x0B,W
09C6:  MOVWF  01
09C8:  MOVLW  00
09CA:  ADDWFC x0C,W
09CC:  MOVWF  03
09CE:  MOVFF  01,FE9
09D2:  MOVLW  04
09D4:  ADDWF  03,W
09D6:  MOVWF  FEA
09D8:  MOVFF  309,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
09DC:  BTFSC  x0A.0
09DE:  BSF    x08.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
09E0:  BTFSC  x0A.1
09E2:  BSF    x08.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
09E4:  MOVF   x06,W
09E6:  MULLW  08
09E8:  MOVF   FF3,W
09EA:  CLRF   x0C
09EC:  MOVWF  FE9
09EE:  MOVLW  04
09F0:  ADDWF  x0C,W
09F2:  MOVWF  FEA
09F4:  MOVFF  308,FEF
.................... } 
09F8:  MOVLB  0
09FA:  RETLW  00
....................  
.................... // see pic18_usb.h for documentation 
.................... int16 usb_rx_packet_size(int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
*
1AAC:  MOVLB  2
1AAE:  MOVF   xEF,W
1AB0:  MULLW  08
1AB2:  MOVF   FF3,W
1AB4:  CLRF   xFA
1AB6:  MOVWF  xF9
1AB8:  MOVLW  02
1ABA:  ADDWF  xF9,W
1ABC:  MOVWF  01
1ABE:  MOVLW  00
1AC0:  ADDWFC xFA,W
1AC2:  MOVWF  03
1AC4:  MOVFF  01,FE9
1AC8:  MOVLW  04
1ACA:  ADDWF  03,W
1ACC:  MOVWF  FEA
1ACE:  MOVFF  FEC,03
1AD2:  MOVF   FED,F
1AD4:  MOVFF  FEF,2F4
1AD8:  MOVFF  03,2F5
....................    i = EP_BDxCNT_O(endpoint); 
1ADC:  MOVF   xEF,W
1ADE:  MULLW  08
1AE0:  MOVF   FF3,W
1AE2:  CLRF   xFA
1AE4:  MOVWF  xF9
1AE6:  MOVLW  01
1AE8:  ADDWF  xF9,W
1AEA:  MOVWF  01
1AEC:  MOVLW  00
1AEE:  ADDWFC xFA,W
1AF0:  MOVWF  03
1AF2:  MOVFF  01,FE9
1AF6:  MOVLW  04
1AF8:  ADDWF  03,W
1AFA:  MOVWF  FEA
1AFC:  MOVF   FEF,W
1AFE:  CLRF   03
1B00:  MOVWF  xF7
1B02:  MOVFF  03,2F8
....................    st = EP_BDxST_O(endpoint); 
1B06:  MOVF   xEF,W
1B08:  MULLW  08
1B0A:  MOVF   FF3,W
1B0C:  CLRF   xFA
1B0E:  MOVWF  FE9
1B10:  MOVLW  04
1B12:  ADDWF  xFA,W
1B14:  MOVWF  FEA
1B16:  MOVFF  FEF,2F6
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
1B1A:  BTFSC  xF6.0
1B1C:  BSF    xF8.0
....................    if (bit_test(st,1)) {bit_set(i,9);} 
1B1E:  BTFSC  xF6.1
1B20:  BSF    xF8.1
....................  
....................    if (i < max) {max = i;} 
1B22:  MOVF   xF8,W
1B24:  SUBWF  xF3,W
1B26:  BNC   1B38
1B28:  BNZ   1B30
1B2A:  MOVF   xF2,W
1B2C:  SUBWF  xF7,W
1B2E:  BC    1B38
1B30:  MOVFF  2F8,2F3
1B34:  MOVFF  2F7,2F2
....................     
....................    memcpy(ptr, al ,max); 
1B38:  MOVFF  2F1,FEA
1B3C:  MOVFF  2F0,FE9
1B40:  MOVFF  2F5,FE2
1B44:  MOVFF  2F4,FE1
1B48:  MOVFF  2F3,02
1B4C:  MOVFF  2F2,01
1B50:  MOVF   01,F
1B52:  BZ    1B58
1B54:  INCF   02,F
1B56:  BRA    1B5C
1B58:  MOVF   02,F
1B5A:  BZ    1B68
1B5C:  MOVFF  FE6,FEE
1B60:  DECFSZ 01,F
1B62:  BRA    1B5C
1B64:  DECFSZ 02,F
1B66:  BRA    1B5C
....................  
....................    return(max); 
1B68:  MOVFF  2F2,01
1B6C:  MOVFF  2F3,02
.................... } 
1B70:  MOVLB  0
1B72:  GOTO   1B8C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(int8 endpoint, int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
1B76:  MOVFF  2EA,2EF
1B7A:  MOVFF  2EC,2F1
1B7E:  MOVFF  2EB,2F0
1B82:  MOVFF  2EE,2F3
1B86:  MOVFF  2ED,2F2
1B8A:  BRA    1AAC
1B8C:  MOVFF  02,2EE
1B90:  MOVFF  01,2ED
1B94:  CLRF   16
1B96:  BTFSC  FF2.7
1B98:  BSF    16.7
1B9A:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
1B9C:  MOVFF  2EA,306
1BA0:  MOVLW  02
1BA2:  MOVLB  3
1BA4:  MOVWF  x07
1BA6:  MOVLB  0
1BA8:  CALL   0932
1BAC:  BTFSC  16.7
1BAE:  BSF    FF2.7
....................  
....................    return(max); 
1BB0:  MOVLB  2
1BB2:  MOVFF  2ED,01
1BB6:  MOVFF  2EE,02
.................... } 
1BBA:  MOVLB  0
1BBC:  GOTO   2B00 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
07F8:  MOVLB  3
07FA:  BCF    x07.0
07FC:  BTFSC  x06.7
07FE:  BSF    x07.0
....................    endpoint &= 0x7F; 
0800:  BCF    x06.7
....................     
....................    if (direction)  
0802:  BTFSS  x07.0
0804:  BRA    0828
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
0806:  MOVF   x06,W
0808:  MULLW  08
080A:  MOVF   FF3,W
080C:  CLRF   x09
080E:  MOVWF  x08
0810:  MOVLW  04
0812:  ADDWF  x08,F
0814:  MOVLW  00
0816:  ADDWFC x09,F
0818:  MOVFF  308,FE9
081C:  MOVLW  04
081E:  ADDWF  x09,W
0820:  MOVWF  FEA
0822:  MOVLW  84
0824:  MOVWF  FEF
....................    } 
....................    else  
0826:  BRA    083C
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
0828:  MOVF   x06,W
082A:  MULLW  08
082C:  MOVF   FF3,W
082E:  CLRF   x09
0830:  MOVWF  FE9
0832:  MOVLW  04
0834:  ADDWF  x09,W
0836:  MOVWF  FEA
0838:  MOVLW  84
083A:  MOVWF  FEF
....................    } 
.................... } 
083C:  MOVLB  0
083E:  GOTO   08D0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
07B0:  MOVLB  3
07B2:  BCF    x07.0
07B4:  BTFSC  x06.7
07B6:  BSF    x07.0
....................    endpoint &= 0x7F; 
07B8:  BCF    x06.7
....................     
....................    if (direction)  
07BA:  BTFSS  x07.0
07BC:  BRA    07E0
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
07BE:  MOVF   x06,W
07C0:  MULLW  08
07C2:  MOVF   FF3,W
07C4:  CLRF   x09
07C6:  MOVWF  x08
07C8:  MOVLW  04
07CA:  ADDWF  x08,F
07CC:  MOVLW  00
07CE:  ADDWFC x09,F
07D0:  MOVFF  308,FE9
07D4:  MOVLW  04
07D6:  ADDWF  x09,W
07D8:  MOVWF  FEA
07DA:  MOVLW  88
07DC:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
07DE:  BRA    07F2
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
07E0:  MOVF   x06,W
07E2:  MULLW  08
07E4:  MOVF   FF3,W
07E6:  CLRF   x09
07E8:  MOVWF  FE9
07EA:  MOVLW  04
07EC:  ADDWF  x09,W
07EE:  MOVWF  FEA
07F0:  CLRF   FEF
....................    } 
.................... } 
07F2:  MOVLB  0
07F4:  GOTO   08C0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0842:  MOVLB  3
0844:  BCF    x07.0
0846:  BTFSC  x06.7
0848:  BSF    x07.0
....................    endpoint &= 0x7F; 
084A:  BCF    x06.7
....................     
....................    if (direction)  
084C:  BTFSS  x07.0
084E:  BRA    0872
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0850:  MOVF   x06,W
0852:  MULLW  08
0854:  MOVF   FF3,W
0856:  CLRF   x0A
0858:  MOVWF  x09
085A:  MOVLW  04
085C:  ADDWF  x09,F
085E:  MOVLW  00
0860:  ADDWFC x0A,F
0862:  MOVFF  309,FE9
0866:  MOVLW  04
0868:  ADDWF  x0A,W
086A:  MOVWF  FEA
086C:  MOVFF  FEF,308
....................    } 
....................    else  
0870:  BRA    0886
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0872:  MOVF   x06,W
0874:  MULLW  08
0876:  MOVF   FF3,W
0878:  CLRF   x0A
087A:  MOVWF  FE9
087C:  MOVLW  04
087E:  ADDWF  x0A,W
0880:  MOVWF  FEA
0882:  MOVFF  FEF,308
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0886:  BTFSS  x08.7
0888:  BRA    088E
088A:  BTFSC  x08.2
088C:  BRA    0892
088E:  MOVLW  00
0890:  BRA    0894
0892:  MOVLW  01
0894:  MOVWF  01
.................... } 
0896:  MOVLB  0
0898:  GOTO   08E8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(int8 address)  
.................... { 
....................    UADDR = address; 
*
0B26:  MOVFF  307,F6E
....................     
....................    if (address)  
0B2A:  MOVLB  3
0B2C:  MOVF   x07,F
0B2E:  BZ    0B36
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0B30:  MOVLW  04
0B32:  MOVWF  22
....................    } 
....................    else  
0B34:  BRA    0B3A
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0B36:  MOVLW  02
0B38:  MOVWF  22
....................    } 
.................... } 
0B3A:  MOVLB  0
0B3C:  GOTO   0B4A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(int8 config)  
.................... { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................     
....................    if (config == 0) 
*
047C:  MOVLB  3
047E:  MOVF   x06,F
0480:  BNZ   048E
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0482:  MOVLW  04
0484:  MOVWF  22
....................       usb_disable_endpoints(); 
0486:  MOVLB  0
0488:  RCALL  02D8
....................    } 
....................    else  
048A:  BRA    0648
048C:  MOVLB  3
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
048E:  MOVLW  05
0490:  MOVWF  22
....................       addy = (int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
0492:  MOVLW  04
0494:  MOVWF  x09
0496:  MOVLW  90
0498:  MOVWF  x08
....................       for (en=1; en<USB_NUM_UEP; en++)  
049A:  MOVLW  01
049C:  MOVWF  x07
049E:  MOVF   x07,W
04A0:  SUBLW  0F
04A2:  BTFSS  FD8.0
04A4:  BRA    0648
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
04A6:  MOVFF  307,30F
04AA:  MOVLB  0
04AC:  RCALL  0284
....................          new_uep = 0; 
04AE:  MOVLB  3
04B0:  CLRF   x0A
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
04B2:  CLRF   03
04B4:  MOVF   x07,W
04B6:  MOVFF  FF2,30E
04BA:  BCF    FF2.7
04BC:  MOVLB  0
04BE:  RCALL  00BA
04C0:  MOVLB  3
04C2:  BTFSC  x0E.7
04C4:  BSF    FF2.7
04C6:  SUBLW  FF
04C8:  BZ    0580
....................          { 
....................             new_uep = 0x04; 
04CA:  MOVLW  04
04CC:  MOVWF  x0A
....................             len = usb_ep_rx_size[en]; 
04CE:  BCF    FD8.0
04D0:  RLCF   x07,W
04D2:  CLRF   03
04D4:  MOVFF  FF2,30E
04D8:  BCF    FF2.7
04DA:  MOVLB  0
04DC:  RCALL  00DA
04DE:  TBLRD*+
04E0:  MOVFF  FF5,03
04E4:  MOVLB  3
04E6:  BTFSC  x0E.7
04E8:  BSF    FF2.7
04EA:  MOVWF  x0B
04EC:  MOVFF  03,30C
....................             EP_BDxCNT_O(en) = len; 
04F0:  MOVF   x07,W
04F2:  MULLW  08
04F4:  MOVF   FF3,W
04F6:  CLRF   x0F
04F8:  MOVWF  x0E
04FA:  MOVLW  01
04FC:  ADDWF  x0E,W
04FE:  MOVWF  01
0500:  MOVLW  00
0502:  ADDWFC x0F,W
0504:  MOVWF  03
0506:  MOVFF  01,FE9
050A:  MOVLW  04
050C:  ADDWF  03,W
050E:  MOVWF  FEA
0510:  MOVFF  30B,FEF
....................             EP_BDxADR_O(en) = addy; 
0514:  MOVF   x07,W
0516:  MULLW  08
0518:  MOVF   FF3,W
051A:  CLRF   x0F
051C:  MOVWF  x0E
051E:  MOVLW  02
0520:  ADDWF  x0E,W
0522:  MOVWF  01
0524:  MOVLW  00
0526:  ADDWFC x0F,W
0528:  MOVWF  03
052A:  MOVFF  01,FE9
052E:  MOVLW  04
0530:  ADDWF  03,W
0532:  MOVWF  FEA
0534:  MOVFF  309,FEC
0538:  MOVF   FED,F
053A:  MOVFF  308,FEF
....................             addy += usb_ep_rx_size[en]; 
053E:  BCF    FD8.0
0540:  RLCF   x07,W
0542:  CLRF   03
0544:  MOVFF  FF2,30E
0548:  BCF    FF2.7
054A:  MOVLB  0
054C:  RCALL  00DA
054E:  TBLRD*+
0550:  MOVFF  FF5,03
0554:  MOVLB  3
0556:  BTFSC  x0E.7
0558:  BSF    FF2.7
055A:  ADDWF  x08,F
055C:  MOVF   03,W
055E:  ADDWFC x09,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0560:  MOVLW  88
0562:  MOVWF  x0D
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0564:  BTFSC  x0C.0
0566:  BSF    x0D.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
0568:  BTFSC  x0C.1
056A:  BSF    x0D.1
....................             EP_BDxST_O(en) = i; 
056C:  MOVF   x07,W
056E:  MULLW  08
0570:  MOVF   FF3,W
0572:  CLRF   x0F
0574:  MOVWF  FE9
0576:  MOVLW  04
0578:  ADDWF  x0F,W
057A:  MOVWF  FEA
057C:  MOVFF  30D,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0580:  CLRF   03
0582:  MOVF   x07,W
0584:  MOVFF  FF2,30E
0588:  BCF    FF2.7
058A:  MOVLB  0
058C:  RCALL  00BA
058E:  MOVLB  3
0590:  BTFSC  x0E.7
0592:  BSF    FF2.7
0594:  SUBLW  FF
0596:  BZ    060E
....................          { 
....................             new_uep |= 0x02; 
0598:  BSF    x0A.1
....................             EP_BDxADR_I(en) = addy; 
059A:  MOVF   x07,W
059C:  MULLW  08
059E:  MOVF   FF3,W
05A0:  CLRF   x0F
05A2:  MOVWF  x0E
05A4:  MOVLW  04
05A6:  ADDWF  x0E,F
05A8:  MOVLW  00
05AA:  ADDWFC x0F,F
05AC:  MOVLW  02
05AE:  ADDWF  x0E,W
05B0:  MOVWF  01
05B2:  MOVLW  00
05B4:  ADDWFC x0F,W
05B6:  MOVWF  03
05B8:  MOVFF  01,FE9
05BC:  MOVLW  04
05BE:  ADDWF  03,W
05C0:  MOVWF  FEA
05C2:  MOVFF  309,FEC
05C6:  MOVF   FED,F
05C8:  MOVFF  308,FEF
....................             addy += usb_ep_tx_size[en]; 
05CC:  BCF    FD8.0
05CE:  RLCF   x07,W
05D0:  CLRF   03
05D2:  MOVFF  FF2,30E
05D6:  BCF    FF2.7
05D8:  MOVLB  0
05DA:  RCALL  00DA
05DC:  TBLRD*+
05DE:  MOVFF  FF5,03
05E2:  MOVLB  3
05E4:  BTFSC  x0E.7
05E6:  BSF    FF2.7
05E8:  ADDWF  x08,F
05EA:  MOVF   03,W
05EC:  ADDWFC x09,F
....................             EP_BDxST_I(en) = 0x40; 
05EE:  MOVF   x07,W
05F0:  MULLW  08
05F2:  MOVF   FF3,W
05F4:  CLRF   x0F
05F6:  MOVWF  x0E
05F8:  MOVLW  04
05FA:  ADDWF  x0E,F
05FC:  MOVLW  00
05FE:  ADDWFC x0F,F
0600:  MOVFF  30E,FE9
0604:  MOVLW  04
0606:  ADDWF  x0F,W
0608:  MOVWF  FEA
060A:  MOVLW  40
060C:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
060E:  MOVF   x0A,W
0610:  SUBLW  06
0612:  BNZ   0618
0614:  MOVLW  0E
0616:  MOVWF  x0A
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
0618:  CLRF   03
061A:  MOVF   x07,W
061C:  MOVFF  FF2,30E
0620:  BCF    FF2.7
0622:  MOVLB  0
0624:  RCALL  00BA
0626:  MOVLB  3
0628:  BTFSC  x0E.7
062A:  BSF    FF2.7
062C:  SUBLW  01
062E:  BTFSS  FD8.2
0630:  BSF    x0A.4
....................           
....................          UEP(en) = new_uep; 
0632:  CLRF   03
0634:  MOVF   x07,W
0636:  ADDLW  70
0638:  MOVWF  FE9
063A:  MOVLW  0F
063C:  ADDWFC 03,W
063E:  MOVWF  FEA
0640:  MOVFF  30A,FEF
....................       } 
0644:  INCF   x07,F
0646:  BRA    049E
0648:  MOVLB  0
....................    } 
.................... } 
064A:  GOTO   06F2 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0284:  CLRF   03
0286:  MOVLB  3
0288:  MOVF   x0F,W
028A:  ADDLW  70
028C:  MOVWF  FE9
028E:  MOVLW  0F
0290:  ADDWFC 03,W
0292:  MOVWF  FEA
0294:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0296:  MOVFF  30F,310
029A:  MOVLB  0
029C:  RCALL  0220
029E:  MOVF   01,F
02A0:  BZ    02D4
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
02A2:  MOVLB  3
02A4:  MOVF   x0F,W
02A6:  MULLW  08
02A8:  MOVF   FF3,W
02AA:  CLRF   x11
02AC:  MOVWF  FE9
02AE:  MOVLW  04
02B0:  ADDWF  x11,W
02B2:  MOVWF  FEA
02B4:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
02B6:  MOVF   x0F,W
02B8:  MULLW  08
02BA:  MOVF   FF3,W
02BC:  CLRF   x11
02BE:  MOVWF  x10
02C0:  MOVLW  04
02C2:  ADDWF  x10,F
02C4:  MOVLW  00
02C6:  ADDWFC x11,F
02C8:  MOVFF  310,FE9
02CC:  MOVLW  04
02CE:  ADDWF  x11,W
02D0:  MOVWF  FEA
02D2:  CLRF   FEF
02D4:  MOVLB  0
....................    } 
.................... } 
02D6:  RETLW  00
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
02D8:  MOVLW  01
02DA:  MOVLB  3
02DC:  MOVWF  x0E
02DE:  MOVF   x0E,W
02E0:  SUBLW  0F
02E2:  BNC   02F2
....................       usb_disable_endpoint(i); 
02E4:  MOVFF  30E,30F
02E8:  MOVLB  0
02EA:  RCALL  0284
02EC:  MOVLB  3
02EE:  INCF   x0E,F
02F0:  BRA    02DE
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
02F2:  MOVLB  0
02F4:  RETLW  00
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #int_usb NOCLEAR 
.................... void usb_isr()  
.................... { 
....................    int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0CEA:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0CEC:  MOVF   22,F
0CEE:  BNZ   0CF2
0CF0:  BRA    0D6E
....................    if (UIR)  
0CF2:  MOVF   F68,F
0CF4:  BZ    0D6E
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0CF6:  BTFSS  F68.2
0CF8:  BRA    0D02
0CFA:  BTFSS  F69.2
0CFC:  BRA    0D02
0CFE:  GOTO   01DA
....................  
....................       if (UCON_SUSPND) return; 
0D02:  BTFSS  F6D.1
0D04:  BRA    0D08
0D06:  BRA    0D6E
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0D08:  BTFSS  F68.5
0D0A:  BRA    0D14
0D0C:  BTFSS  F69.5
0D0E:  BRA    0D14
0D10:  GOTO   020A
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0D14:  BTFSS  F68.1
0D16:  BRA    0D20
0D18:  BTFSS  F69.1
0D1A:  BRA    0D20
0D1C:  GOTO   0218
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
0D20:  BTFSS  F68.0
0D22:  BRA    0D2C
0D24:  BTFSS  F69.0
0D26:  BRA    0D2C
0D28:  GOTO   031E
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0D2C:  BTFSS  F68.4
0D2E:  BRA    0D38
0D30:  BTFSS  F69.4
0D32:  BRA    0D38
0D34:  GOTO   0348
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0D38:  BTFSS  F68.6
0D3A:  BRA    0D44
0D3C:  BTFSS  F69.6
0D3E:  BRA    0D44
0D40:  GOTO   0352
....................  
....................       TRNAttempts = 0; 
0D44:  MOVLB  3
0D46:  CLRF   x03
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0D48:  BTFSS  F68.3
0D4A:  BRA    0D60
0D4C:  BTFSS  F69.3
0D4E:  BRA    0D60
....................          { 
....................             USTATCopy = U1STAT; 
0D50:  MOVFF  F6C,21
....................             usb_clear_trn(); 
0D54:  MOVLB  0
0D56:  CALL   0004
....................             usb_isr_tok_dne(); 
0D5A:  BRA    0B70
....................          } 
....................          else 
0D5C:  BRA    0D62
0D5E:  MOVLB  3
....................             break; 
0D60:  BRA    0D6C
....................       } while (TRNAttempts++ < 4); 
0D62:  MOVLB  3
0D64:  MOVF   x03,W
0D66:  INCF   x03,F
0D68:  SUBLW  03
0D6A:  BC    0D48
0D6C:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
0D6E:  GOTO   0078
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
0352:  BCF    F68.6
.................... } 
0354:  GOTO   0D44 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
031E:  CLRF   F6A
....................    UIR = 0; 
0320:  CLRF   F68
....................    UEIE = 0x9F; 
0322:  MOVLW  9F
0324:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0326:  MOVLW  3D
0328:  MOVWF  F69
....................  
....................    UADDR = 0; 
032A:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
032C:  RCALL  02D8
....................     
....................    usb_token_reset(); 
032E:  RCALL  02F6
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
0330:  MOVLW  16
0332:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
0334:  BTFSS  F68.3
0336:  BRA    033C
....................       usb_clear_trn(); 
0338:  RCALL  0004
....................    } 
033A:  BRA    0334
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
033C:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
033E:  RCALL  01EA
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0340:  MOVLW  03
0342:  MOVWF  22
.................... } 
0344:  GOTO   0D2C (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
01EA:  MOVLW  40
01EC:  MOVLB  4
01EE:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
01F0:  MOVLW  04
01F2:  MOVWF  x03
01F4:  MOVLW  10
01F6:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
01F8:  MOVLW  88
01FA:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
01FC:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
01FE:  MOVLW  04
0200:  MOVWF  x07
0202:  MOVLW  50
0204:  MOVWF  x06
.................... } 
0206:  MOVLB  0
0208:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0218:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
021A:  BCF    F68.1
.................... } 
021C:  GOTO   0D20 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0348:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
034A:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
034C:  BSF    F6D.1
.................... } 
034E:  GOTO   0D38 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
01DA:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
01DC:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
01DE:  BTFSS  F68.2
01E0:  BRA    01E6
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
01E2:  BCF    F68.2
....................    } 
01E4:  BRA    01DE
.................... } 
01E6:  GOTO   0D02 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
020A:  BTFSS  F70.0
020C:  BRA    0212
....................    { 
....................       usb_init_ep0_setup(); 
020E:  RCALL  01EA
....................       bit_clear(UEP(0), 0); 
0210:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0212:  BCF    F68.5
.................... } 
0214:  GOTO   0D14 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0358:  MOVFF  309,23
035C:  RETLW  00
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
035E:  MOVLW  FF
0360:  MOVWF  23
0362:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0B70:  RRCF   21,W
0B72:  MOVLB  3
0B74:  MOVWF  x04
0B76:  RRCF   x04,F
0B78:  RRCF   x04,F
0B7A:  MOVLW  1F
0B7C:  ANDWF  x04,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0B7E:  MOVF   21,F
0B80:  BNZ   0C20
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0B82:  MOVLB  4
0B84:  MOVF   x00,W
0B86:  ANDLW  3C
0B88:  MOVLB  3
0B8A:  MOVWF  x05
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0B8C:  MOVLW  43
0B8E:  MOVLB  4
0B90:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0B92:  MOVLB  3
0B94:  MOVF   x05,W
0B96:  SUBLW  34
0B98:  BNZ   0BE4
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0B9A:  MOVLB  4
0B9C:  MOVF   x04,W
0B9E:  ANDLW  80
0BA0:  BZ    0BA4
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0BA2:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0BA4:  MOVLB  0
0BA6:  BRA    0906
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0BA8:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0BAA:  INCFSZ 23,W
0BAC:  BRA    0BBC
....................             usb_flush_out(0, USB_DTS_STALL); 
0BAE:  MOVLB  3
0BB0:  CLRF   x06
0BB2:  MOVLW  03
0BB4:  MOVWF  x07
0BB6:  MOVLB  0
0BB8:  RCALL  0932
....................          else  
0BBA:  BRA    0BE0
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0BBC:  MOVLB  3
0BBE:  CLRF   x06
0BC0:  MOVLW  02
0BC2:  MOVWF  x07
0BC4:  MOVLB  0
0BC6:  RCALL  0932
....................             if (__setup_0_tx_size != 0xFE) 
0BC8:  MOVF   23,W
0BCA:  SUBLW  FE
0BCC:  BZ    0BE0
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0BCE:  MOVLB  3
0BD0:  CLRF   x06
0BD2:  CLRF   x08
0BD4:  MOVFF  23,307
0BD8:  MOVLW  04
0BDA:  MOVWF  x09
0BDC:  MOVLB  0
0BDE:  RCALL  0A40
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
0BE0:  BRA    0C1C
0BE2:  MOVLB  3
0BE4:  MOVF   x05,W
0BE6:  SUBLW  04
0BE8:  BNZ   0C1E
....................       { 
....................          usb_isr_tok_out_dne(0); 
0BEA:  CLRF   x06
0BEC:  MOVLB  0
0BEE:  RCALL  0B1C
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0BF0:  MOVLB  3
0BF2:  CLRF   x06
0BF4:  MOVLW  02
0BF6:  MOVWF  x07
0BF8:  MOVLB  0
0BFA:  RCALL  0932
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0BFC:  MOVF   23,W
0BFE:  SUBLW  FE
0C00:  BZ    0C1A
0C02:  INCFSZ 23,W
0C04:  BRA    0C08
0C06:  BRA    0C1A
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0C08:  MOVLB  3
0C0A:  CLRF   x06
0C0C:  CLRF   x08
0C0E:  MOVFF  23,307
0C12:  MOVLW  01
0C14:  MOVWF  x09
0C16:  MOVLB  0
0C18:  RCALL  0A40
....................          } 
....................       } 
....................       else 
0C1A:  BRA    0C1C
0C1C:  MOVLB  3
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
0C1E:  BRA    0CE4
0C20:  MOVF   21,W
0C22:  SUBLW  04
0C24:  BNZ   0C56
....................    {    
....................       //pic -> host transfer completed 
....................       EP_BDxST_I(0) = EP_BDxST_I(0) & 0x43;   //clear up any BDSTAL confusion 
0C26:  MOVLW  43
0C28:  MOVLB  4
0C2A:  ANDWF  x04,F
....................       __setup_0_tx_size = 0xFF; 
0C2C:  MOVLW  FF
0C2E:  MOVWF  23
....................       usb_isr_tok_in_dne(0); 
0C30:  MOVLB  3
0C32:  CLRF   x06
0C34:  MOVLB  0
0C36:  RCALL  0B4E
....................       if (__setup_0_tx_size!=0xFF) 
0C38:  INCFSZ 23,W
0C3A:  BRA    0C3E
0C3C:  BRA    0C52
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0C3E:  MOVLB  3
0C40:  CLRF   x06
0C42:  CLRF   x08
0C44:  MOVFF  23,307
0C48:  MOVLW  02
0C4A:  MOVWF  x09
0C4C:  MOVLB  0
0C4E:  RCALL  0A40
....................       else 
0C50:  BRA    0C52
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
0C52:  BRA    0CE2
0C54:  MOVLB  3
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0C56:  BTFSC  21.2
0C58:  BRA    0C94
....................       { 
....................          EP_BDxST_O(en) = EP_BDxST_O(en) & 0x43;   //clear up any BDSTAL confusion 
0C5A:  MOVF   x04,W
0C5C:  MULLW  08
0C5E:  MOVF   FF3,W
0C60:  CLRF   x07
0C62:  MOVWF  01
0C64:  MOVLW  04
0C66:  ADDWF  x07,W
0C68:  MOVWF  03
0C6A:  MOVF   x04,W
0C6C:  MULLW  08
0C6E:  MOVF   FF3,W
0C70:  CLRF   x09
0C72:  MOVWF  FE9
0C74:  MOVLW  04
0C76:  ADDWF  x09,W
0C78:  MOVWF  FEA
0C7A:  MOVF   FEF,W
0C7C:  ANDLW  43
0C7E:  MOVFF  03,FEA
0C82:  MOVFF  01,FE9
0C86:  MOVWF  FEF
....................          usb_isr_tok_out_dne(en); 
0C88:  MOVFF  304,306
0C8C:  MOVLB  0
0C8E:  RCALL  0B1C
....................       } 
....................       else  
0C90:  BRA    0CE2
0C92:  MOVLB  3
....................       { 
....................          EP_BDxST_I(en) = EP_BDxST_I(en) & 0x43;   //clear up any BDSTAL confusion 
0C94:  MOVF   x04,W
0C96:  MULLW  08
0C98:  MOVF   FF3,W
0C9A:  CLRF   x07
0C9C:  MOVWF  x06
0C9E:  MOVLW  04
0CA0:  ADDWF  x06,F
0CA2:  MOVLW  00
0CA4:  ADDWFC x07,F
0CA6:  MOVFF  306,01
0CAA:  MOVLW  04
0CAC:  ADDWF  x07,W
0CAE:  MOVWF  03
0CB0:  MOVF   x04,W
0CB2:  MULLW  08
0CB4:  MOVF   FF3,W
0CB6:  CLRF   x09
0CB8:  MOVWF  x08
0CBA:  MOVLW  04
0CBC:  ADDWF  x08,F
0CBE:  MOVLW  00
0CC0:  ADDWFC x09,F
0CC2:  MOVFF  308,FE9
0CC6:  MOVLW  04
0CC8:  ADDWF  x09,W
0CCA:  MOVWF  FEA
0CCC:  MOVF   FEF,W
0CCE:  ANDLW  43
0CD0:  MOVFF  03,FEA
0CD4:  MOVFF  306,FE9
0CD8:  MOVWF  FEF
....................          usb_isr_tok_in_dne(en); 
0CDA:  MOVFF  304,306
0CDE:  MOVLB  0
0CE0:  RCALL  0B4E
0CE2:  MOVLB  3
....................       } 
....................    } 
.................... } 
0CE4:  MOVLB  0
0CE6:  GOTO   0D5C (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; unsigned int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1A68:  MOVF   1E,W
1A6A:  MOVWF  01
.................... } 
1A6C:  GOTO   2AD0 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
*
02F6:  MOVLB  3
02F8:  CLRF   x04
02FA:  MOVF   x04,F
02FC:  BNZ   0312
....................       USB_Interface[i] = 0;   //reset each interface to default 
02FE:  CLRF   03
0300:  MOVF   x04,W
0302:  ADDLW  27
0304:  MOVWF  FE9
0306:  MOVLW  00
0308:  ADDWFC 03,W
030A:  MOVWF  FEA
030C:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
030E:  INCF   x04,F
0310:  BRA    02FA
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0312:  CLRF   1E
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0314:  MOVLW  01
0316:  MOVWF  1F
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0318:  CLRF   1D
.................... } 
031A:  MOVLB  0
031C:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0220:  MOVLB  3
0222:  BCF    x11.0
0224:  BTFSC  x10.7
0226:  BSF    x11.0
....................     
....................    endpoint &= 0x7F; 
0228:  BCF    x10.7
....................     
....................    if (endpoint > 16) 
022A:  MOVF   x10,W
022C:  SUBLW  10
022E:  BC    0236
....................       return(FALSE); 
0230:  MOVLW  00
0232:  MOVWF  01
0234:  BRA    0280
....................     
....................    if (direction) { //IN 
0236:  BTFSS  x11.0
0238:  BRA    025E
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
023A:  CLRF   03
023C:  MOVF   x10,W
023E:  MOVFF  FF2,312
0242:  BCF    FF2.7
0244:  MOVLB  0
0246:  RCALL  00BA
0248:  MOVLB  3
024A:  BTFSC  x12.7
024C:  BSF    FF2.7
024E:  SUBLW  FF
0250:  BNZ   0256
0252:  MOVLW  00
0254:  BRA    0258
0256:  MOVLW  01
0258:  MOVWF  01
025A:  BRA    0280
....................    } 
....................    else {   //OUT 
025C:  BRA    0280
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
025E:  CLRF   03
0260:  MOVF   x10,W
0262:  MOVFF  FF2,312
0266:  BCF    FF2.7
0268:  MOVLB  0
026A:  RCALL  00BA
026C:  MOVLB  3
026E:  BTFSC  x12.7
0270:  BSF    FF2.7
0272:  SUBLW  FF
0274:  BNZ   027A
0276:  MOVLW  00
0278:  BRA    027C
027A:  MOVLW  01
027C:  MOVWF  01
027E:  BRA    0280
....................    } 
.................... } 
0280:  MOVLB  0
0282:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
0B4E:  MOVLB  3
0B50:  MOVF   x06,F
0B52:  BNZ   0B6C
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0B54:  DECFSZ 1D,W
0B56:  BRA    0B60
0B58:  MOVLB  0
0B5A:  RCALL  0364
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0B5C:  BRA    0B6A
0B5E:  MOVLB  3
0B60:  MOVF   1D,W
0B62:  SUBLW  02
0B64:  BNZ   0B6C
0B66:  MOVLB  0
0B68:  BRA    0B40
0B6A:  MOVLB  3
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
0B6C:  MOVLB  0
0B6E:  RETLW  00
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0B1C:  MOVLB  3
0B1E:  MOVF   x06,F
0B20:  BNZ   0B22
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0B22:  MOVLB  0
0B24:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0906:  CLRF   1D
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0908:  MOVLB  4
090A:  MOVF   x10,W
090C:  ANDLW  7F
090E:  XORLW  00
0910:  MOVLB  0
0912:  BZ    091E
0914:  XORLW  01
0916:  BZ    0922
0918:  XORLW  03
091A:  BZ    0926
091C:  BRA    092A
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
091E:  BRA    064E
....................          break; 
0920:  BRA    092E
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0922:  BRA    0706
....................          break; 
0924:  BRA    092E
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0926:  BRA    089C
....................          break; 
0928:  BRA    092E
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
092A:  RCALL  035E
....................          break; 
092C:  BRA    092E
....................    } 
.................... } 
092E:  GOTO   0BA8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
064E:  MOVLB  4
0650:  MOVF   x11,W
0652:  XORLW  00
0654:  MOVLB  0
0656:  BZ    0672
0658:  XORLW  01
065A:  BZ    0686
065C:  XORLW  02
065E:  BZ    06A0
0660:  XORLW  06
0662:  BZ    06B8
0664:  XORLW  03
0666:  BZ    06CA
0668:  XORLW  0E
066A:  BZ    06CE
066C:  XORLW  01
066E:  BZ    06DE
0670:  BRA    06FE
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0672:  MOVFF  1F,450
....................             usb_ep0_tx_buffer[1]=0; 
0676:  MOVLB  4
0678:  CLRF   x51
....................             usb_request_send_response(2); 
067A:  MOVLW  02
067C:  MOVLB  3
067E:  MOVWF  x09
0680:  MOVLB  0
0682:  RCALL  0358
....................             break; 
0684:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0686:  MOVLB  4
0688:  DECFSZ x12,W
068A:  BRA    069A
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
068C:  MOVLW  01
068E:  ANDWF  1F,F
....................                usb_put_0len_0(); 
0690:  MOVLB  3
0692:  CLRF   x09
0694:  MOVLB  0
0696:  RCALL  0358
....................             } 
....................             else 
0698:  BRA    069E
....................                usb_request_stall(); 
069A:  MOVLB  0
069C:  RCALL  035E
....................             break; 
069E:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
06A0:  MOVLB  4
06A2:  DECFSZ x12,W
06A4:  BRA    06B2
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
06A6:  BSF    1F.1
....................                usb_put_0len_0(); 
06A8:  MOVLB  3
06AA:  CLRF   x09
06AC:  MOVLB  0
06AE:  RCALL  0358
....................             } 
....................             else 
06B0:  BRA    06B6
....................                usb_request_stall(); 
06B2:  MOVLB  0
06B4:  RCALL  035E
....................             break; 
06B6:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
06B8:  MOVLW  02
06BA:  MOVWF  1D
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
06BC:  MOVFF  412,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
06C0:  MOVLB  3
06C2:  CLRF   x09
06C4:  MOVLB  0
06C6:  RCALL  0358
....................             break; 
06C8:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
06CA:  BRA    03FE
....................             break; 
06CC:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
06CE:  MOVFF  1E,450
....................             usb_request_send_response(1); 
06D2:  MOVLW  01
06D4:  MOVLB  3
06D6:  MOVWF  x09
06D8:  MOVLB  0
06DA:  RCALL  0358
....................             break; 
06DC:  BRA    0702
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
06DE:  MOVLB  4
06E0:  MOVF   x12,W
06E2:  SUBLW  01
06E4:  BNC   06FA
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
06E6:  MOVFF  412,1E
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
06EA:  MOVFF  412,306
06EE:  MOVLB  0
06F0:  BRA    047C
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
06F2:  MOVLB  3
06F4:  CLRF   x09
06F6:  MOVLB  0
06F8:  RCALL  0358
....................             } 
....................             break; 
06FA:  MOVLB  0
06FC:  BRA    0702
....................  
....................       default: 
....................             usb_request_stall(); 
06FE:  RCALL  035E
....................             break; 
0700:  BRA    0702
....................    } 
.................... } 
0702:  GOTO   092E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
0706:  MOVFF  1E,306
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
070A:  MOVLB  4
070C:  MOVF   x11,W
070E:  XORLW  00
0710:  MOVLB  0
0712:  BZ    071E
0714:  XORLW  0A
0716:  BZ    0730
0718:  XORLW  01
071A:  BZ    077E
071C:  BRA    07A8
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
071E:  MOVLB  4
0720:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0; 
0722:  CLRF   x51
....................             usb_request_send_response(2); 
0724:  MOVLW  02
0726:  MOVLB  3
0728:  MOVWF  x09
072A:  MOVLB  0
072C:  RCALL  0358
....................             break; 
072E:  BRA    07AC
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0730:  MOVLB  3
0732:  MOVF   x06,F
0734:  BZ    0778
0736:  MOVLW  01
0738:  SUBWF  x06,W
073A:  CLRF   03
073C:  MOVFF  FF2,307
0740:  BCF    FF2.7
0742:  MOVLB  0
0744:  RCALL  014C
0746:  MOVLB  3
0748:  BTFSC  x07.7
074A:  BSF    FF2.7
074C:  MOVWF  01
074E:  MOVLB  4
0750:  SUBWF  x14,W
0752:  BTFSS  FD8.0
0754:  BRA    075A
0756:  MOVLB  3
0758:  BRA    0778
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
075A:  CLRF   03
075C:  MOVF   x14,W
075E:  ADDLW  27
0760:  MOVWF  FE9
0762:  MOVLW  00
0764:  ADDWFC 03,W
0766:  MOVWF  FEA
0768:  MOVFF  FEF,450
....................                usb_request_send_response(1);; //send byte back 
076C:  MOVLW  01
076E:  MOVLB  3
0770:  MOVWF  x09
0772:  MOVLB  0
0774:  RCALL  0358
....................             } 
....................             else 
0776:  BRA    077C
....................                usb_request_stall(); 
0778:  MOVLB  0
077A:  RCALL  035E
....................             break; 
077C:  BRA    07AC
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
077E:  MOVLB  3
0780:  MOVF   x06,F
0782:  BZ    07A2
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0784:  CLRF   03
0786:  MOVLB  4
0788:  MOVF   x14,W
078A:  ADDLW  27
078C:  MOVWF  FE9
078E:  MOVLW  00
0790:  ADDWFC 03,W
0792:  MOVWF  FEA
0794:  MOVFF  412,FEF
....................                usb_put_0len_0(); 
0798:  MOVLB  3
079A:  CLRF   x09
079C:  MOVLB  0
079E:  RCALL  0358
....................             } 
....................             else 
07A0:  BRA    07A6
....................                usb_request_stall(); 
07A2:  MOVLB  0
07A4:  RCALL  035E
....................             break; 
07A6:  BRA    07AC
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
07A8:  RCALL  035E
....................             break; 
07AA:  BRA    07AC
....................    } 
.................... } 
07AC:  GOTO   092E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
089C:  MOVFF  414,310
08A0:  RCALL  0220
08A2:  MOVF   01,F
08A4:  BZ    0902
....................       switch(usb_ep0_rx_buffer[1]) { 
08A6:  MOVLB  4
08A8:  MOVF   x11,W
08AA:  XORLW  01
08AC:  MOVLB  0
08AE:  BZ    08BA
08B0:  XORLW  02
08B2:  BZ    08CA
08B4:  XORLW  03
08B6:  BZ    08DA
08B8:  BRA    08FE
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
08BA:  MOVFF  414,306
08BE:  BRA    07B0
....................                usb_put_0len_0(); 
08C0:  MOVLB  3
08C2:  CLRF   x09
08C4:  MOVLB  0
08C6:  RCALL  0358
....................                break; 
08C8:  BRA    0902
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
08CA:  MOVFF  414,306
08CE:  BRA    07F8
....................                      usb_put_0len_0(); 
08D0:  MOVLB  3
08D2:  CLRF   x09
08D4:  MOVLB  0
08D6:  RCALL  0358
....................                      break; 
08D8:  BRA    0902
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
08DA:  MOVLB  4
08DC:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0; 
08DE:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
08E0:  MOVFF  414,306
08E4:  MOVLB  0
08E6:  BRA    0842
08E8:  MOVF   01,F
08EA:  BZ    08F2
....................                   usb_ep0_tx_buffer[0]=1; 
08EC:  MOVLW  01
08EE:  MOVLB  4
08F0:  MOVWF  x50
....................                } 
....................                usb_request_send_response(2); 
08F2:  MOVLW  02
08F4:  MOVLB  3
08F6:  MOVWF  x09
08F8:  MOVLB  0
08FA:  RCALL  0358
....................                break; 
08FC:  BRA    0902
....................  
....................          default: 
....................             usb_request_stall(); 
08FE:  RCALL  035E
....................             break; 
0900:  BRA    0902
....................       } 
....................    } 
.................... } 
0902:  GOTO   092E (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
03FE:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
0400:  CLRF   20
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
0402:  MOVLB  4
0404:  MOVF   x13,W
0406:  XORLW  01
0408:  MOVLB  0
040A:  BZ    0416
040C:  XORLW  03
040E:  BZ    0420
0410:  XORLW  01
0412:  BZ    0426
0414:  BRA    045C
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
0416:  MOVLW  12
0418:  MOVWF  26
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
041A:  MOVLW  03
041C:  MOVWF  20
....................             break; 
041E:  BRA    0460
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
0420:  MOVLW  20
0422:  MOVWF  26
....................             break; 
0424:  BRA    0460
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0426:  MOVLW  02
0428:  MOVWF  20
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
042A:  CLRF   03
042C:  MOVLB  4
042E:  MOVF   x12,W
0430:  MOVFF  FF2,306
0434:  BCF    FF2.7
0436:  MOVLB  0
0438:  RCALL  0180
043A:  MOVLB  3
043C:  BTFSC  x06.7
043E:  BSF    FF2.7
0440:  MOVWF  25
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
0442:  CLRF   03
0444:  MOVF   25,W
0446:  MOVFF  FF2,306
044A:  BCF    FF2.7
044C:  MOVLB  0
044E:  RCALL  0194
0450:  MOVLB  3
0452:  BTFSC  x06.7
0454:  BSF    FF2.7
0456:  MOVWF  26
....................             break; 
0458:  MOVLB  0
045A:  BRA    0460
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
045C:  RCALL  035E
....................             return; 
045E:  BRA    0478
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0460:  MOVLB  4
0462:  MOVF   x17,F
0464:  BNZ   0470
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
0466:  MOVF   26,W
0468:  SUBWF  x16,W
046A:  BC    0470
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
046C:  MOVFF  416,26
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0470:  MOVLW  01
0472:  MOVWF  1D
....................    usb_copy_desc_seg_to_ep(); 
0474:  MOVLB  0
0476:  RCALL  0364
.................... } 
0478:  GOTO   0702 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0B40:  CLRF   1E
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0B42:  CLRF   1D
....................    usb_set_address(USB_address_pending); 
0B44:  MOVFF  24,307
0B48:  BRA    0B26
....................    #endif 
.................... } 
0B4A:  GOTO   0B6A (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0364:  MOVLB  3
0366:  CLRF   x07
....................    unsigned int i=0; 
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0368:  MOVF   26,F
036A:  BZ    03E8
036C:  MOVF   x07,W
036E:  SUBLW  3F
0370:  BNC   03E8
....................       switch(USB_stack_status.getdesc_type) { 
0372:  MOVF   20,W
0374:  XORLW  00
0376:  MOVLB  0
0378:  BZ    0384
037A:  XORLW  02
037C:  BZ    039C
037E:  XORLW  01
0380:  BZ    03B4
0382:  BRA    03CC
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0384:  CLRF   03
0386:  MOVF   25,W
0388:  MOVFF  FF2,309
038C:  BCF    FF2.7
038E:  RCALL  011C
0390:  MOVLB  3
0392:  BTFSC  x09.7
0394:  BSF    FF2.7
0396:  MOVWF  x08
....................             break; 
0398:  MOVLB  0
039A:  BRA    03CC
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
039C:  CLRF   03
039E:  MOVF   25,W
03A0:  MOVFF  FF2,309
03A4:  BCF    FF2.7
03A6:  RCALL  0194
03A8:  MOVLB  3
03AA:  BTFSC  x09.7
03AC:  BSF    FF2.7
03AE:  MOVWF  x08
....................             break; 
03B0:  MOVLB  0
03B2:  BRA    03CC
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
03B4:  CLRF   03
03B6:  MOVF   25,W
03B8:  MOVFF  FF2,309
03BC:  BCF    FF2.7
03BE:  RCALL  015E
03C0:  MOVLB  3
03C2:  BTFSC  x09.7
03C4:  BSF    FF2.7
03C6:  MOVWF  x08
....................             break; 
03C8:  MOVLB  0
03CA:  BRA    03CC
....................       } 
....................       usb_getdesc_ptr++; 
03CC:  INCF   25,F
....................       usb_getdesc_len--; 
03CE:  DECF   26,F
....................       usb_ep0_tx_buffer[i++]=c; 
03D0:  MOVLB  3
03D2:  MOVF   x07,W
03D4:  INCF   x07,F
03D6:  CLRF   03
03D8:  ADDLW  50
03DA:  MOVWF  FE9
03DC:  MOVLW  04
03DE:  ADDWFC 03,W
03E0:  MOVWF  FEA
03E2:  MOVFF  308,FEF
....................    } 
03E6:  BRA    0368
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
03E8:  MOVF   26,F
03EA:  BNZ   03F4
03EC:  MOVF   x07,W
03EE:  SUBLW  40
03F0:  BZ    03F4
....................          USB_stack_status.dev_req = NONE; 
03F2:  CLRF   1D
....................    } 
....................  
....................    usb_request_send_response(i); 
03F4:  MOVFF  307,309
03F8:  MOVLB  0
03FA:  RCALL  0358
.................... } 
03FC:  RETLW  00
....................  
.................... #ENDIF 
....................  
.................... const int8 Lenbuf = 32;  
.................... int8 recbuf[Lenbuf]; 
.................... int8 rxbuf[Lenbuf]; 
....................  
.................... float promedio[80]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float PromPresion[20]={0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; 
.................... float X[2]={0.0,0.0}; 
.................... float promediopresion=0.0,Aumento=0.0; 
.................... short emergency=0,desfoguelento=0,flag_agua=0,TiempoFuncionamiento=0,flag_agua2=0,CamaraOUT=0,CamaraIN=0,flag_reservorio=0,flag_presostato=0; 
.................... int8 Menu=1,bite=0,TamanoCadena=0,i=0,Posicion=0,Decimal=0,r=0,t=0,TiempoControl=0,q=0,z=0; 
.................... int8 Resistencia=0,EVDesfogue=0,EVAgua=0,EVTrampa=0,MotorPuerta=0,EVEntradaAgua=0,BombaVacio=0,BombaAgua=0,Control=0,Alarma=0,AlarmaAgua=0,AlarmaTemp=0; 
.................... int8 Puerta=0,Parada=0,NivelReservorio=0,NivelTanque=0,Presostato=0,ADC_Pt100=0,y=0,Chksum=0; 
.................... int16 tiempos=0,tiempos3=0,tiempoctrl=0,Minutos=15,Nivel=0,t_exhaust=0,tinicio=0,tagua=0,treservorio=0; 
.................... short disp_Calentando=0,disp_Llenando=0,disp_Secando=0,disp_Esterilizando=0,disp_Despresurizando=0,disp_Stop=0,disp_Door=0,disp_Fin=0,CadenaRecibida=0; 
.................... signed int  Testerilizacion[4]={0,0,0,0};   // Tiempo transcurrido 
.................... signed int  Testerilizacionp[4]={0,0,0,0};   // Tiempo transcurrido 
.................... signed int  Tsecado[4]={0,0,0,0};   // Tiempo transcurrido 
.................... signed int  Tsecadop[4]={0,0,0,0};   // Tiempo transcurrido 
.................... // Variables para Pt100 
.................... short Lectura=0,Expulsa=0, est=0,Visua=0,flagtimer=0; 
.................... int8 h=0,l=0,Ajuste=0,Ajusten=0,R2=0,fin_ciclo=0,tiempo_desfogue=0,tiempo_esterilizacion=0,tiempo_secado=0,Exhaust=0,p=0,MediaMovil=2; 
.................... float V0=0.0,R1=10000.0,Pt,Tciclo=10.0,Tpulso=0.0,error=0.0,Prom=0.0,Temperature=0.0,tmp=0.0,Ganancia=25.0,Ganancia2=20.0,desvio=0.0,d3=0.0,d4=0.0,d5=0.0; 
.................... float V1=0.0,Presion=0.0,d6=0.0,d7=0.0,d8=0.0; 
.................... float Setpoint=0.0,Temperatura=0.0,TempUSB=0.0,PresionCamara=0.0,K=0.006429; 
....................  
.................... char dato[14]; 
.................... char datoTx[11]; 
.................... char datoRx[14]; 
.................... char ADCTemperatura[4]; 
.................... char SetTemperatura[3]={0,0,0}; 
....................  
.................... #int_rda 
.................... void rda_isr(void)//función de interrupción por recepción de datos USART  
.................... {  
....................    dato[bite]=getch(); 
*
0DEA:  CLRF   03
0DEC:  MOVLB  2
0DEE:  MOVF   x0B,W
0DF0:  ADDLW  BC
0DF2:  MOVWF  FE9
0DF4:  MOVLW  02
0DF6:  ADDWFC 03,W
0DF8:  MOVWF  FEA
0DFA:  BTFSS  F9E.5
0DFC:  BRA    0DFA
0DFE:  MOVFF  FAE,FEF
....................     
....................    if((bite<13 && strcmp(dato[bite],'\r')==0)) 
0E02:  MOVF   x0B,W
0E04:  SUBLW  0C
0E06:  BNC   0E3C
0E08:  CLRF   03
0E0A:  MOVF   x0B,W
0E0C:  ADDLW  BC
0E0E:  MOVWF  FE9
0E10:  MOVLW  02
0E12:  ADDWFC 03,W
0E14:  MOVWF  FEA
0E16:  MOVFF  FEF,303
0E1A:  MOVLB  3
0E1C:  CLRF   x05
0E1E:  MOVFF  303,304
0E22:  CLRF   x07
0E24:  MOVLW  0D
0E26:  MOVWF  x06
0E28:  MOVLB  0
0E2A:  RCALL  0D72
0E2C:  MOVF   01,F
0E2E:  BTFSC  FD8.2
0E30:  BRA    0E36
0E32:  MOVLB  2
0E34:  BRA    0E3C
....................    { 
....................       bite=0; 
0E36:  MOVLB  2
0E38:  CLRF   x0B
....................    } 
....................    else 
0E3A:  BRA    0ECE
....................    { 
....................       if(bite==13 && strcmp(dato[bite],'\r')==0) 
0E3C:  MOVF   x0B,W
0E3E:  SUBLW  0D
0E40:  BNZ   0EC0
0E42:  CLRF   03
0E44:  MOVF   x0B,W
0E46:  ADDLW  BC
0E48:  MOVWF  FE9
0E4A:  MOVLW  02
0E4C:  ADDWFC 03,W
0E4E:  MOVWF  FEA
0E50:  MOVFF  FEF,303
0E54:  MOVLB  3
0E56:  CLRF   x05
0E58:  MOVFF  303,304
0E5C:  CLRF   x07
0E5E:  MOVLW  0D
0E60:  MOVWF  x06
0E62:  MOVLB  0
0E64:  RCALL  0D72
0E66:  MOVF   01,F
0E68:  BTFSC  FD8.2
0E6A:  BRA    0E70
0E6C:  MOVLB  2
0E6E:  BRA    0EC0
....................       { 
....................          TamanoCadena=bite; 
0E70:  MOVFF  20B,20C
....................          bite=0; 
0E74:  MOVLB  2
0E76:  CLRF   x0B
....................          CadenaRecibida=1; 
0E78:  BSF    x3B.1
....................          for(i=0;i<TamanoCadena+1;i++) 
0E7A:  CLRF   x0D
0E7C:  MOVLW  01
0E7E:  ADDWF  x0C,W
0E80:  SUBWF  x0D,W
0E82:  BC    0EBE
....................          { 
....................             datoRx[i]=dato[i]; 
0E84:  CLRF   03
0E86:  MOVF   x0D,W
0E88:  ADDLW  D5
0E8A:  MOVWF  01
0E8C:  MOVLW  02
0E8E:  ADDWFC 03,F
0E90:  MOVLB  3
0E92:  MOVFF  03,304
0E96:  CLRF   03
0E98:  MOVLB  2
0E9A:  MOVF   x0D,W
0E9C:  ADDLW  BC
0E9E:  MOVWF  FE9
0EA0:  MOVLW  02
0EA2:  ADDWFC 03,W
0EA4:  MOVWF  FEA
0EA6:  MOVFF  FEF,305
0EAA:  MOVLB  3
0EAC:  MOVFF  304,FEA
0EB0:  MOVFF  01,FE9
0EB4:  MOVFF  305,FEF
....................          }    
0EB8:  MOVLB  2
0EBA:  INCF   x0D,F
0EBC:  BRA    0E7C
....................       } 
....................       else 
0EBE:  BRA    0ECE
....................       { 
....................          if(bite>13) 
0EC0:  MOVF   x0B,W
0EC2:  SUBLW  0D
0EC4:  BC    0ECA
....................          { 
....................             bite=0; 
0EC6:  CLRF   x0B
....................          } 
....................          else 
0EC8:  BRA    0ECE
....................          { 
....................             CadenaRecibida=0; 
0ECA:  BCF    x3B.1
....................             bite++; 
0ECC:  INCF   x0B,F
....................          } 
....................       } 
....................    } 
.................... } 
....................  
0ECE:  BCF    F9E.5
0ED0:  MOVLB  0
0ED2:  GOTO   0078
.................... void ActualizaRecta(){ 
....................    X[y]=Temperature; 
*
1688:  MOVLB  2
168A:  MOVF   x27,W
168C:  MULLW  04
168E:  MOVF   FF3,W
1690:  CLRF   03
1692:  ADDLW  F8
1694:  MOVWF  FE9
1696:  MOVLW  01
1698:  ADDWFC 03,W
169A:  MOVWF  FEA
169C:  MOVFF  274,FEF
16A0:  MOVFF  275,FEC
16A4:  MOVFF  276,FEC
16A8:  MOVFF  277,FEC
....................    y++; 
16AC:  INCF   x27,F
....................    if(y>=2) 
16AE:  MOVF   x27,W
16B0:  SUBLW  01
16B2:  BC    16EE
....................    { 
....................       y=0; 
16B4:  CLRF   x27
....................       Aumento=X[1]-X[0]; 
16B6:  BSF    FD8.1
16B8:  MOVFF  1FF,2F6
16BC:  MOVFF  1FE,2F5
16C0:  MOVFF  1FD,2F4
16C4:  MOVFF  1FC,2F3
16C8:  MOVFF  1FB,2FA
16CC:  MOVFF  1FA,2F9
16D0:  MOVFF  1F9,2F8
16D4:  MOVFF  1F8,2F7
16D8:  MOVLB  0
16DA:  RCALL  135C
16DC:  MOVFF  03,207
16E0:  MOVFF  02,206
16E4:  MOVFF  01,205
16E8:  MOVFF  00,204
16EC:  MOVLB  2
....................    } 
.................... } 
16EE:  MOVLB  0
16F0:  GOTO   1856 (RETURN)
....................  
.................... // Funcion para conversor analogo-digital 
.................... float sensores(int x){ 
.................... float y;set_adc_channel(x);delay_ms(1);y=read_adc();return (y); 
*
103E:  MOVLB  2
1040:  RLCF   xEB,W
1042:  MOVWF  00
1044:  RLCF   00,F
1046:  MOVLW  FC
1048:  ANDWF  00,F
104A:  MOVFF  00,01
104E:  MOVF   FC2,W
1050:  ANDLW  C3
1052:  IORWF  00,W
1054:  MOVWF  FC2
1056:  MOVLW  01
1058:  MOVWF  xF0
105A:  MOVLB  0
105C:  RCALL  0FDE
105E:  BSF    FC2.1
1060:  BTFSC  FC2.1
1062:  BRA    1060
1064:  MOVFF  FC4,2F1
1068:  MOVFF  FC3,2F0
106C:  MOVLB  0
106E:  RCALL  1008
1070:  MOVFF  03,2EF
1074:  MOVFF  02,2EE
1078:  MOVFF  01,2ED
107C:  MOVFF  00,2EC
1080:  MOVFF  2EC,00
1084:  MOVFF  2ED,01
1088:  MOVFF  2EE,02
108C:  MOVFF  2EF,03
.................... } 
1090:  RETLW  00
.................... float Leer_Sensor(int media) 
.................... { 
....................    Prom=0.0; 
*
16F4:  MOVLB  2
16F6:  CLRF   x73
16F8:  CLRF   x72
16FA:  CLRF   x71
16FC:  CLRF   x70
....................    V0 = sensores(0);   //Lectura de Divisor de Voltaje de PT100 con resistencia de 6.18k (+-2%) 
16FE:  CLRF   xEB
1700:  MOVLB  0
1702:  RCALL  103E
1704:  MOVFF  03,25B
1708:  MOVFF  02,25A
170C:  MOVFF  01,259
1710:  MOVFF  00,258
....................    V0 = V0/49.7; // Se elimina la ganancia 
1714:  MOVFF  25B,2F2
1718:  MOVFF  25A,2F1
171C:  MOVFF  259,2F0
1720:  MOVFF  258,2EF
1724:  MOVLW  CD
1726:  MOVLB  2
1728:  MOVWF  xF6
172A:  MOVLW  CC
172C:  MOVWF  xF5
172E:  MOVLW  46
1730:  MOVWF  xF4
1732:  MOVLW  84
1734:  MOVWF  xF3
1736:  MOVLB  0
1738:  RCALL  11FE
173A:  MOVFF  03,25B
173E:  MOVFF  02,25A
1742:  MOVFF  01,259
1746:  MOVFF  00,258
....................    Pt=(R1+(float)R2)/((1023.0/V0)-1.0); // Se calcula el valor de la PT100 
174A:  MOVLB  2
174C:  CLRF   xF1
174E:  MOVFF  250,2F0
1752:  MOVLB  0
1754:  RCALL  1008
1756:  BCF    FD8.1
1758:  MOVFF  25F,2F6
175C:  MOVFF  25E,2F5
1760:  MOVFF  25D,2F4
1764:  MOVFF  25C,2F3
1768:  MOVFF  03,2FA
176C:  MOVFF  02,2F9
1770:  MOVFF  01,2F8
1774:  MOVFF  00,2F7
1778:  RCALL  135C
177A:  MOVFF  00,2EB
177E:  MOVFF  01,2EC
1782:  MOVFF  02,2ED
1786:  MOVFF  03,2EE
178A:  MOVLB  2
178C:  CLRF   xF2
178E:  MOVLW  C0
1790:  MOVWF  xF1
1792:  MOVLW  7F
1794:  MOVWF  xF0
1796:  MOVLW  88
1798:  MOVWF  xEF
179A:  MOVFF  25B,2F6
179E:  MOVFF  25A,2F5
17A2:  MOVFF  259,2F4
17A6:  MOVFF  258,2F3
17AA:  MOVLB  0
17AC:  RCALL  11FE
17AE:  MOVFF  00,2EF
17B2:  MOVFF  01,2F0
17B6:  MOVFF  02,2F1
17BA:  MOVFF  03,2F2
17BE:  BSF    FD8.1
17C0:  MOVFF  03,2F6
17C4:  MOVFF  02,2F5
17C8:  MOVFF  01,2F4
17CC:  MOVFF  00,2F3
17D0:  MOVLB  2
17D2:  CLRF   xFA
17D4:  CLRF   xF9
17D6:  CLRF   xF8
17D8:  MOVLW  7F
17DA:  MOVWF  xF7
17DC:  MOVLB  0
17DE:  RCALL  135C
17E0:  MOVFF  2EE,2F2
17E4:  MOVFF  2ED,2F1
17E8:  MOVFF  2EC,2F0
17EC:  MOVFF  2EB,2EF
17F0:  MOVFF  03,2F6
17F4:  MOVFF  02,2F5
17F8:  MOVFF  01,2F4
17FC:  MOVFF  00,2F3
1800:  RCALL  11FE
1802:  MOVFF  03,263
1806:  MOVFF  02,262
180A:  MOVFF  01,261
180E:  MOVFF  00,260
....................    Pt=Pt-0.5; 
1812:  BSF    FD8.1
1814:  MOVFF  263,2F6
1818:  MOVFF  262,2F5
181C:  MOVFF  261,2F4
1820:  MOVFF  260,2F3
1824:  MOVLB  2
1826:  CLRF   xFA
1828:  CLRF   xF9
182A:  CLRF   xF8
182C:  MOVLW  7E
182E:  MOVWF  xF7
1830:  MOVLB  0
1832:  RCALL  135C
1834:  MOVFF  03,263
1838:  MOVFF  02,262
183C:  MOVFF  01,261
1840:  MOVFF  00,260
....................    //Temperature=(Pt-100.0)/(0.385);  // Ecuación determinada por linealización en Matlab. Revisar este polinomio.   
....................              
....................    if(l>(media-1)) 
1844:  MOVLW  01
1846:  MOVLB  2
1848:  SUBWF  xEA,W
184A:  SUBWF  x4D,W
184C:  BZ    1858
184E:  BNC   1858
....................    {l=0;ActualizaRecta();} 
1850:  CLRF   x4D
1852:  MOVLB  0
1854:  BRA    1688
1856:  MOVLB  2
1858:  CLRF   16
185A:  BTFSC  FF2.7
185C:  BSF    16.7
185E:  BCF    FF2.7
....................    //promedio[l]=Temperature;l++; 
....................    promedio[l]=Pt;l++; 
1860:  MOVLB  3
1862:  CLRF   x04
1864:  MOVFF  24D,303
1868:  CLRF   x06
186A:  MOVLW  04
186C:  MOVWF  x05
186E:  MOVLB  0
1870:  CALL   0ED6
1874:  BTFSC  16.7
1876:  BSF    FF2.7
1878:  MOVF   01,W
187A:  ADDLW  68
187C:  MOVWF  FE9
187E:  MOVLW  00
1880:  ADDWFC 02,W
1882:  MOVWF  FEA
1884:  MOVFF  260,FEF
1888:  MOVFF  261,FEC
188C:  MOVFF  262,FEC
1890:  MOVFF  263,FEC
1894:  MOVLB  2
1896:  INCF   x4D,F
....................           
....................    for(h=0;h<media;h++) 
1898:  CLRF   x4C
189A:  MOVF   xEA,W
189C:  SUBWF  x4C,W
189E:  BC    192A
18A0:  CLRF   16
18A2:  BTFSC  FF2.7
18A4:  BSF    16.7
18A6:  BCF    FF2.7
....................    { 
....................       Prom+=promedio[h]; 
18A8:  MOVLB  3
18AA:  CLRF   x04
18AC:  MOVFF  24C,303
18B0:  CLRF   x06
18B2:  MOVLW  04
18B4:  MOVWF  x05
18B6:  MOVLB  0
18B8:  CALL   0ED6
18BC:  BTFSC  16.7
18BE:  BSF    FF2.7
18C0:  MOVFF  02,03
18C4:  MOVF   01,W
18C6:  ADDLW  68
18C8:  MOVWF  FE9
18CA:  MOVLW  00
18CC:  ADDWFC 02,W
18CE:  MOVWF  FEA
18D0:  MOVFF  FEF,00
18D4:  MOVFF  FEC,01
18D8:  MOVFF  FEC,02
18DC:  MOVFF  FEC,03
18E0:  MOVFF  FEA,2EC
18E4:  MOVFF  FE9,2EB
18E8:  BCF    FD8.1
18EA:  MOVFF  273,2F6
18EE:  MOVFF  272,2F5
18F2:  MOVFF  271,2F4
18F6:  MOVFF  270,2F3
18FA:  MOVFF  03,2FA
18FE:  MOVFF  02,2F9
1902:  MOVFF  01,2F8
1906:  MOVFF  00,2F7
190A:  RCALL  135C
190C:  MOVFF  2EC,FEA
1910:  MOVFF  2EB,FE9
1914:  MOVFF  03,273
1918:  MOVFF  02,272
191C:  MOVFF  01,271
1920:  MOVFF  00,270
....................    }  
1924:  MOVLB  2
1926:  INCF   x4C,F
1928:  BRA    189A
....................    Prom=Prom/media;    
192A:  CLRF   xF1
192C:  MOVFF  2EA,2F0
1930:  MOVLB  0
1932:  CALL   1008
1936:  MOVFF  273,2F2
193A:  MOVFF  272,2F1
193E:  MOVFF  271,2F0
1942:  MOVFF  270,2EF
1946:  MOVFF  03,2F6
194A:  MOVFF  02,2F5
194E:  MOVFF  01,2F4
1952:  MOVFF  00,2F3
1956:  RCALL  11FE
1958:  MOVFF  03,273
195C:  MOVFF  02,272
1960:  MOVFF  01,271
1964:  MOVFF  00,270
....................    Temperature=(Prom-100.0)/(0.385);  // Ecuación determinada por linealización en Matlab. Revisar este polinomio.   
1968:  BSF    FD8.1
196A:  MOVFF  273,2F6
196E:  MOVFF  272,2F5
1972:  MOVFF  271,2F4
1976:  MOVFF  270,2F3
197A:  MOVLB  2
197C:  CLRF   xFA
197E:  CLRF   xF9
1980:  MOVLW  48
1982:  MOVWF  xF8
1984:  MOVLW  85
1986:  MOVWF  xF7
1988:  MOVLB  0
198A:  RCALL  135C
198C:  MOVFF  00,2EB
1990:  MOVFF  01,2EC
1994:  MOVFF  02,2ED
1998:  MOVFF  03,2EE
199C:  MOVFF  03,2F2
19A0:  MOVFF  02,2F1
19A4:  MOVFF  01,2F0
19A8:  MOVFF  00,2EF
19AC:  MOVLW  B8
19AE:  MOVLB  2
19B0:  MOVWF  xF6
19B2:  MOVLW  1E
19B4:  MOVWF  xF5
19B6:  MOVLW  45
19B8:  MOVWF  xF4
19BA:  MOVLW  7D
19BC:  MOVWF  xF3
19BE:  MOVLB  0
19C0:  RCALL  11FE
19C2:  MOVFF  03,277
19C6:  MOVFF  02,276
19CA:  MOVFF  01,275
19CE:  MOVFF  00,274
....................    //Prom+=((float)Ajuste-(float)Ajusten); 
....................    Temperature+=((float)Ajuste-(float)Ajusten); 
19D2:  MOVLB  2
19D4:  CLRF   xF1
19D6:  MOVFF  24E,2F0
19DA:  MOVLB  0
19DC:  CALL   1008
19E0:  MOVFF  00,2EB
19E4:  MOVFF  01,2EC
19E8:  MOVFF  02,2ED
19EC:  MOVFF  03,2EE
19F0:  MOVLB  2
19F2:  CLRF   xF1
19F4:  MOVFF  24F,2F0
19F8:  MOVLB  0
19FA:  CALL   1008
19FE:  BSF    FD8.1
1A00:  MOVFF  2EE,2F6
1A04:  MOVFF  2ED,2F5
1A08:  MOVFF  2EC,2F4
1A0C:  MOVFF  2EB,2F3
1A10:  MOVFF  03,2FA
1A14:  MOVFF  02,2F9
1A18:  MOVFF  01,2F8
1A1C:  MOVFF  00,2F7
1A20:  RCALL  135C
1A22:  BCF    FD8.1
1A24:  MOVFF  277,2F6
1A28:  MOVFF  276,2F5
1A2C:  MOVFF  275,2F4
1A30:  MOVFF  274,2F3
1A34:  MOVFF  03,2FA
1A38:  MOVFF  02,2F9
1A3C:  MOVFF  01,2F8
1A40:  MOVFF  00,2F7
1A44:  RCALL  135C
1A46:  MOVFF  03,277
1A4A:  MOVFF  02,276
1A4E:  MOVFF  01,275
1A52:  MOVFF  00,274
....................     
....................    //return Prom; 
....................    return Temperature; 
1A56:  MOVFF  274,00
1A5A:  MOVFF  275,01
1A5E:  MOVFF  276,02
1A62:  MOVFF  277,03
.................... } 
1A66:  RETLW  00
....................  
.................... float Leer_Sensor_Presion(int media){ 
....................    promediopresion=0.0; 
*
1DE0:  MOVLB  2
1DE2:  CLRF   x03
1DE4:  CLRF   x02
1DE6:  CLRF   x01
1DE8:  CLRF   x00
....................    V1 = sensores(1);   //Lectura de Divisor de Voltaje de PT100 con resistencia de 1k (+-10%) 
1DEA:  MOVLW  01
1DEC:  MOVWF  xEB
1DEE:  MOVLB  0
1DF0:  CALL   103E
1DF4:  MOVFF  03,297
1DF8:  MOVFF  02,296
1DFC:  MOVFF  01,295
1E00:  MOVFF  00,294
....................    V1 = V1*(5.0/1023.0); 
1E04:  MOVFF  297,2F1
1E08:  MOVFF  296,2F0
1E0C:  MOVFF  295,2EF
1E10:  MOVFF  294,2EE
1E14:  MOVLW  0A
1E16:  MOVLB  2
1E18:  MOVWF  xF5
1E1A:  MOVLW  28
1E1C:  MOVWF  xF4
1E1E:  MOVLW  20
1E20:  MOVWF  xF3
1E22:  MOVLW  77
1E24:  MOVWF  xF2
1E26:  MOVLB  0
1E28:  RCALL  1BC0
1E2A:  MOVFF  03,297
1E2E:  MOVFF  02,296
1E32:  MOVFF  01,295
1E36:  MOVFF  00,294
....................    Presion=(V1-0.2)/(K); 
1E3A:  BSF    FD8.1
1E3C:  MOVFF  297,2F6
1E40:  MOVFF  296,2F5
1E44:  MOVFF  295,2F4
1E48:  MOVFF  294,2F3
1E4C:  MOVLW  CD
1E4E:  MOVLB  2
1E50:  MOVWF  xFA
1E52:  MOVLW  CC
1E54:  MOVWF  xF9
1E56:  MOVLW  4C
1E58:  MOVWF  xF8
1E5A:  MOVLW  7C
1E5C:  MOVWF  xF7
1E5E:  MOVLB  0
1E60:  CALL   135C
1E64:  MOVFF  00,2EB
1E68:  MOVFF  01,2EC
1E6C:  MOVFF  02,2ED
1E70:  MOVFF  03,2EE
1E74:  MOVFF  03,2F2
1E78:  MOVFF  02,2F1
1E7C:  MOVFF  01,2F0
1E80:  MOVFF  00,2EF
1E84:  MOVFF  2BB,2F6
1E88:  MOVFF  2BA,2F5
1E8C:  MOVFF  2B9,2F4
1E90:  MOVFF  2B8,2F3
1E94:  CALL   11FE
1E98:  MOVFF  03,29B
1E9C:  MOVFF  02,29A
1EA0:  MOVFF  01,299
1EA4:  MOVFF  00,298
....................     
....................    if(Presion<0.0) 
1EA8:  MOVFF  29B,2EE
1EAC:  MOVFF  29A,2ED
1EB0:  MOVFF  299,2EC
1EB4:  MOVFF  298,2EB
1EB8:  MOVLB  2
1EBA:  CLRF   xF2
1EBC:  CLRF   xF1
1EBE:  CLRF   xF0
1EC0:  CLRF   xEF
1EC2:  MOVLB  0
1EC4:  RCALL  1D66
1EC6:  BNC   1ED2
....................    { 
....................       Presion=0.0; 
1EC8:  MOVLB  2
1ECA:  CLRF   x9B
1ECC:  CLRF   x9A
1ECE:  CLRF   x99
1ED0:  CLRF   x98
....................    } 
....................     
....................    if(r>media-1) 
1ED2:  MOVLW  01
1ED4:  MOVLB  2
1ED6:  SUBWF  xEA,W
1ED8:  SUBWF  x10,W
1EDA:  BZ    1EE0
1EDC:  BNC   1EE0
....................    {r=0;} 
1EDE:  CLRF   x10
....................    PromPresion[r]=Presion;r++; 
1EE0:  MOVF   x10,W
1EE2:  MULLW  04
1EE4:  MOVF   FF3,W
1EE6:  CLRF   03
1EE8:  ADDLW  A8
1EEA:  MOVWF  FE9
1EEC:  MOVLW  01
1EEE:  ADDWFC 03,W
1EF0:  MOVWF  FEA
1EF2:  MOVFF  298,FEF
1EF6:  MOVFF  299,FEC
1EFA:  MOVFF  29A,FEC
1EFE:  MOVFF  29B,FEC
1F02:  INCF   x10,F
....................           
....................    for(t=0;t<=(media-1);t++) 
1F04:  CLRF   x11
1F06:  MOVLW  01
1F08:  SUBWF  xEA,W
1F0A:  SUBWF  x11,W
1F0C:  BZ    1F10
1F0E:  BC    1F80
....................    { 
....................       promediopresion+=PromPresion[t]; 
1F10:  MOVF   x11,W
1F12:  MULLW  04
1F14:  MOVF   FF3,W
1F16:  CLRF   03
1F18:  ADDLW  A8
1F1A:  MOVWF  FE9
1F1C:  MOVLW  01
1F1E:  ADDWFC 03,W
1F20:  MOVWF  FEA
1F22:  MOVFF  FEF,00
1F26:  MOVFF  FEC,01
1F2A:  MOVFF  FEC,02
1F2E:  MOVFF  FEC,03
1F32:  MOVFF  FEA,2EC
1F36:  MOVFF  FE9,2EB
1F3A:  BCF    FD8.1
1F3C:  MOVFF  203,2F6
1F40:  MOVFF  202,2F5
1F44:  MOVFF  201,2F4
1F48:  MOVFF  200,2F3
1F4C:  MOVFF  03,2FA
1F50:  MOVFF  02,2F9
1F54:  MOVFF  01,2F8
1F58:  MOVFF  00,2F7
1F5C:  MOVLB  0
1F5E:  CALL   135C
1F62:  MOVFF  2EC,FEA
1F66:  MOVFF  2EB,FE9
1F6A:  MOVFF  03,203
1F6E:  MOVFF  02,202
1F72:  MOVFF  01,201
1F76:  MOVFF  00,200
....................    }  
1F7A:  MOVLB  2
1F7C:  INCF   x11,F
1F7E:  BRA    1F06
....................    promediopresion=promediopresion/media;    
1F80:  CLRF   xF1
1F82:  MOVFF  2EA,2F0
1F86:  MOVLB  0
1F88:  CALL   1008
1F8C:  MOVFF  203,2F2
1F90:  MOVFF  202,2F1
1F94:  MOVFF  201,2F0
1F98:  MOVFF  200,2EF
1F9C:  MOVFF  03,2F6
1FA0:  MOVFF  02,2F5
1FA4:  MOVFF  01,2F4
1FA8:  MOVFF  00,2F3
1FAC:  CALL   11FE
1FB0:  MOVFF  03,203
1FB4:  MOVFF  02,202
1FB8:  MOVFF  01,201
1FBC:  MOVFF  00,200
....................     
....................    return promediopresion; 
1FC0:  MOVFF  200,00
1FC4:  MOVFF  201,01
1FC8:  MOVFF  202,02
1FCC:  MOVFF  203,03
.................... } 
1FD0:  GOTO   323E (RETURN)
....................  
.................... void EnviarCodigo(void) 
.................... { 
....................    datoTx[0]=Puerta+48; 
*
1158:  MOVLW  30
115A:  MOVLB  2
115C:  ADDWF  x21,W
115E:  MOVWF  xCA
....................    datoTx[1]=Parada+48; 
1160:  MOVLW  30
1162:  ADDWF  x22,W
1164:  MOVWF  xCB
....................    datoTx[2]=NivelReservorio+48; 
1166:  MOVLW  30
1168:  ADDWF  x23,W
116A:  MOVWF  xCC
....................    //datoTx[3]=NivelTanque+48; 
....................    datoTx[3]=flag_agua+48; 
116C:  MOVLW  00
116E:  BTFSC  x08.2
1170:  MOVLW  01
1172:  ADDLW  30
1174:  MOVWF  xCD
....................    datoTx[4]=Presostato+48; 
1176:  MOVLW  30
1178:  ADDWF  x25,W
117A:  MOVWF  xCE
....................    //datoTx[4]=EVAgua+48; 
....................    datoTx[5]=((int8)Temperatura)+48; 
117C:  MOVFF  2AF,2ED
1180:  MOVFF  2AE,2EC
1184:  MOVFF  2AD,2EB
1188:  MOVFF  2AC,2EA
118C:  MOVLB  0
118E:  RCALL  1112
1190:  MOVLW  30
1192:  ADDWF  01,W
1194:  MOVLB  2
1196:  MOVWF  xCF
....................    datoTx[6]=Alarma+48; 
1198:  MOVLW  30
119A:  ADDWF  x1E,W
119C:  MOVWF  xD0
....................    datoTx[7]=AlarmaAgua+48; 
119E:  MOVLW  30
11A0:  ADDWF  x1F,W
11A2:  MOVWF  xD1
....................    datoTx[8]=Chksum+48; 
11A4:  MOVLW  30
11A6:  ADDWF  x28,W
11A8:  MOVWF  xD2
....................    //itoa(Leer_Sensor(5),10,ADCTemperatura); 
....................    /*for(i=0;i<4;i++) 
....................    { 
....................       if(ADCTemperatura[i]==null) 
....................       { 
....................          datoTx[i+5]='n'; 
....................       } 
....................       else 
....................       { 
....................          datoTx[i+5]=ADCTemperatura[i]; 
....................       } 
....................    }*/ 
....................    datoTx[9]=((int8)d3)+48; 
11AA:  MOVFF  28B,2ED
11AE:  MOVFF  28A,2EC
11B2:  MOVFF  289,2EB
11B6:  MOVFF  288,2EA
11BA:  MOVLB  0
11BC:  RCALL  1112
11BE:  MOVLW  30
11C0:  ADDWF  01,W
11C2:  MOVLB  2
11C4:  MOVWF  xD3
....................    datoTx[10]='\r'; 
11C6:  MOVLW  0D
11C8:  MOVWF  xD4
....................    for(q=0;q<11;q++) 
11CA:  CLRF   x13
11CC:  MOVF   x13,W
11CE:  SUBLW  0A
11D0:  BNC   11FA
....................    { 
....................       putc(datoTx[q]); 
11D2:  CLRF   03
11D4:  MOVF   x13,W
11D6:  ADDLW  CA
11D8:  MOVWF  FE9
11DA:  MOVLW  02
11DC:  ADDWFC 03,W
11DE:  MOVWF  FEA
11E0:  MOVFF  FEF,2EA
11E4:  MOVF   xEA,W
11E6:  MOVLB  0
11E8:  BRA    114E
....................       delay_ms(10); 
11EA:  MOVLW  0A
11EC:  MOVLB  2
11EE:  MOVWF  xF0
11F0:  MOVLB  0
11F2:  RCALL  0FDE
....................    }    
11F4:  MOVLB  2
11F6:  INCF   x13,F
11F8:  BRA    11CC
.................... } 
11FA:  MOVLB  0
11FC:  RETLW  00
....................  
.................... void Determina(void){ 
....................    Resistencia=datoRx[0]-48; 
*
234A:  MOVLW  30
234C:  MOVLB  2
234E:  SUBWF  xD5,W
2350:  MOVWF  x15
....................    EVDesfogue=datoRx[1]-48; 
2352:  MOVLW  30
2354:  SUBWF  xD6,W
2356:  MOVWF  x16
....................    EVAgua=datoRx[2]-48; 
2358:  MOVLW  30
235A:  SUBWF  xD7,W
235C:  MOVWF  x17
....................    EVTrampa=datoRx[3]-48; 
235E:  MOVLW  30
2360:  SUBWF  xD8,W
2362:  MOVWF  x18
....................    MotorPuerta=datoRx[4]-48; 
2364:  MOVLW  30
2366:  SUBWF  xD9,W
2368:  MOVWF  x19
....................    EVEntradaAgua=datoRx[5]-48; 
236A:  MOVLW  30
236C:  SUBWF  xDA,W
236E:  MOVWF  x1A
....................    BombaVacio=datoRx[6]-48; 
2370:  MOVLW  30
2372:  SUBWF  xDB,W
2374:  MOVWF  x1B
....................    BombaAgua=datoRx[7]-48; 
2376:  MOVLW  30
2378:  SUBWF  xDC,W
237A:  MOVWF  x1C
....................    Control=datoRx[8]-48; 
237C:  MOVLW  30
237E:  SUBWF  xDD,W
2380:  MOVWF  x1D
....................    Nivel=datoRx[12]-48;  
2382:  MOVLW  30
2384:  SUBWF  xE1,W
2386:  MOVWF  x31
2388:  CLRF   x32
....................    Setpoint=datoRx[9]-48; 
238A:  MOVLW  30
238C:  SUBWF  xDE,W
238E:  CLRF   xF1
2390:  MOVWF  xF0
2392:  MOVLB  0
2394:  CALL   1008
2398:  MOVFF  03,2AB
239C:  MOVFF  02,2AA
23A0:  MOVFF  01,2A9
23A4:  MOVFF  00,2A8
....................    Chksum=datoRx[10]-48; 
23A8:  MOVLW  30
23AA:  MOVLB  2
23AC:  SUBWF  xDF,W
23AE:  MOVWF  x28
....................    /*   for(i=0;i<3;i++) 
....................       { 
....................          if(strcmp(datoRx[i+9],'n')==0) 
....................          { 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             SetTemperatura[i]=datoRx[i+9]; 
....................          } 
....................       }      
....................       Setpoint=atof(SetTemperatura);*/ 
.................... } 
23B0:  MOVLB  0
23B2:  GOTO   3544 (RETURN)
....................  
.................... #int_TIMER0 
.................... void temp0s(void){ 
....................    set_timer0(0); 
*
0EF8:  CLRF   FD7
0EFA:  CLRF   FD6
....................    t_exhaust++; 
0EFC:  MOVLB  2
0EFE:  INCF   x33,F
0F00:  BTFSC  FD8.2
0F02:  INCF   x34,F
....................    if(EVDesfogue==2 && Presostato>=2) 
0F04:  MOVF   x16,W
0F06:  SUBLW  02
0F08:  BNZ   0F72
0F0A:  MOVF   x25,W
0F0C:  SUBLW  01
0F0E:  BC    0F72
....................    { 
....................       EV_Agua_off; 
0F10:  BCF    F8A.2
0F12:  BCF    F93.2
....................       Resistencia_off; 
0F14:  BCF    F8A.0
0F16:  BCF    F93.0
....................       if(Nivel<6) 
0F18:  MOVF   x32,F
0F1A:  BNZ   0F6E
0F1C:  MOVF   x31,W
0F1E:  SUBLW  05
0F20:  BNC   0F6E
....................       {   
....................          if(t_exhaust<=(9990*Nivel)) // Si el tiempo es menor o igual al tiempo de control se enciende la resistencia de lo contrario se apaga. 
0F22:  MOVLW  27
0F24:  MOVLB  3
0F26:  MOVWF  x04
0F28:  MOVLW  06
0F2A:  MOVWF  x03
0F2C:  MOVFF  232,306
0F30:  MOVFF  231,305
0F34:  MOVLB  0
0F36:  RCALL  0ED6
0F38:  MOVFF  02,03
0F3C:  MOVF   01,W
0F3E:  MOVLB  2
0F40:  MOVF   x34,W
0F42:  SUBWF  02,W
0F44:  BNC   0F54
0F46:  BNZ   0F4E
0F48:  MOVF   x33,W
0F4A:  SUBWF  01,W
0F4C:  BNC   0F54
....................          { 
....................             //Resistencia_on; 
....................             EV_Desfogue_on; 
0F4E:  BSF    F8A.1
0F50:  BCF    F93.1
....................          } 
....................          else          
0F52:  BRA    0F58
....................          { 
....................             //Resistencia_off; 
....................             EV_Desfogue_off; 
0F54:  BCF    F8A.1
0F56:  BCF    F93.1
....................          }    
....................        
....................          if(t_exhaust>=60000) // Si el tiempo de control es mayor al tiempo de ciclo se reinicia tiempo de control 
0F58:  MOVF   x34,W
0F5A:  SUBLW  E9
0F5C:  BC    0F6C
0F5E:  XORLW  FF
0F60:  BNZ   0F68
0F62:  MOVF   x33,W
0F64:  SUBLW  5F
0F66:  BC    0F6C
....................          { 
....................             t_exhaust=0; 
0F68:  CLRF   x34
0F6A:  CLRF   x33
....................          } // tiempoctrl incrementa una unidad cada Xms, por eso se dividen los tiempos por 0.005. 
....................       } 
....................       else 
0F6C:  BRA    0F72
....................       { 
....................          EV_Desfogue_on; 
0F6E:  BSF    F8A.1
0F70:  BCF    F93.1
....................       } 
....................    } 
.................... } 
....................  
0F72:  BCF    FF2.2
0F74:  MOVLB  0
0F76:  GOTO   0078
.................... #int_TIMER1 
.................... void temp1s(void){ 
....................     
....................    //set_timer1(45612);  // 5 ms 5536 , Posiblemente cargar con 22144 debido a F=12MHz 
....................    set_timer1(5536); 
0F7A:  MOVLW  15
0F7C:  MOVWF  FCF
0F7E:  MOVLW  A0
0F80:  MOVWF  FCE
....................    tiempos++; 
0F82:  MOVLB  2
0F84:  INCF   x29,F
0F86:  BTFSC  FD8.2
0F88:  INCF   x2A,F
....................    tiempos3++; 
0F8A:  INCF   x2B,F
0F8C:  BTFSC  FD8.2
0F8E:  INCF   x2C,F
....................    tiempoctrl++; 
0F90:  INCF   x2D,F
0F92:  BTFSC  FD8.2
0F94:  INCF   x2E,F
....................     
....................    if(flag_reservorio==1) 
0F96:  BTFSS  x08.7
0F98:  BRA    0FA0
....................    { 
....................       treservorio++; 
0F9A:  INCF   x39,F
0F9C:  BTFSC  FD8.2
0F9E:  INCF   x3A,F
....................    } 
....................        
....................    if(tiempos3==100) 
0FA0:  MOVF   x2B,W
0FA2:  SUBLW  64
0FA4:  BNZ   0FB0
0FA6:  MOVF   x2C,F
0FA8:  BNZ   0FB0
....................    {tiempos3=0;Expulsa=1;} 
0FAA:  CLRF   x2C
0FAC:  CLRF   x2B
0FAE:  BSF    x3B.3
....................     
....................    if(tiempos>=200)  // 12000 para que incremente cada minuto, 200para que incremente cada segundo. 
0FB0:  MOVF   x2A,F
0FB2:  BNZ   0FBA
0FB4:  MOVF   x29,W
0FB6:  SUBLW  C7
0FB8:  BC    0FD6
....................    { 
....................       tiempos=0;Lectura=1;TiempoControl++; 
0FBA:  CLRF   x2A
0FBC:  CLRF   x29
0FBE:  BSF    x3B.2
0FC0:  INCF   x12,F
....................       if(EVAgua!=0) 
0FC2:  MOVF   x17,F
0FC4:  BZ    0FD6
....................       { 
....................          tinicio++; 
0FC6:  INCF   x35,F
0FC8:  BTFSC  FD8.2
0FCA:  INCF   x36,F
....................          if(flag_agua2==0) 
0FCC:  BTFSC  x08.4
0FCE:  BRA    0FD6
....................          { 
....................             tagua++; 
0FD0:  INCF   x37,F
0FD2:  BTFSC  FD8.2
0FD4:  INCF   x38,F
....................          } 
....................       } 
....................    } 
.................... } 
....................  
0FD6:  BCF    F9E.0
0FD8:  MOVLB  0
0FDA:  GOTO   0078
.................... void Controla(){ 
.................... //-------------------------------Control de Calentamiento------------------------------------------------------------//          
....................    error=desvio+Setpoint-Temperatura;      // Cálculo del error ****** 
*
1FD4:  BCF    FD8.1
1FD6:  MOVFF  287,2F6
1FDA:  MOVFF  286,2F5
1FDE:  MOVFF  285,2F4
1FE2:  MOVFF  284,2F3
1FE6:  MOVFF  2AB,2FA
1FEA:  MOVFF  2AA,2F9
1FEE:  MOVFF  2A9,2F8
1FF2:  MOVFF  2A8,2F7
1FF6:  CALL   135C
1FFA:  MOVFF  00,2EA
1FFE:  MOVFF  01,2EB
2002:  MOVFF  02,2EC
2006:  MOVFF  03,2ED
200A:  BSF    FD8.1
200C:  MOVFF  03,2F6
2010:  MOVFF  02,2F5
2014:  MOVFF  01,2F4
2018:  MOVFF  00,2F3
201C:  MOVFF  2AF,2FA
2020:  MOVFF  2AE,2F9
2024:  MOVFF  2AD,2F8
2028:  MOVFF  2AC,2F7
202C:  CALL   135C
2030:  MOVFF  03,26F
2034:  MOVFF  02,26E
2038:  MOVFF  01,26D
203C:  MOVFF  00,26C
....................     
....................    if(error>0.9 && error<15 && Aumento<0.3) 
2040:  MOVLW  66
2042:  MOVLB  2
2044:  MOVWF  xEE
2046:  MOVWF  xED
2048:  MOVWF  xEC
204A:  MOVLW  7E
204C:  MOVWF  xEB
204E:  MOVFF  26F,2F2
2052:  MOVFF  26E,2F1
2056:  MOVFF  26D,2F0
205A:  MOVFF  26C,2EF
205E:  MOVLB  0
2060:  RCALL  1D66
2062:  BNC   2110
2064:  MOVFF  26F,2EE
2068:  MOVFF  26E,2ED
206C:  MOVFF  26D,2EC
2070:  MOVFF  26C,2EB
2074:  MOVLB  2
2076:  CLRF   xF2
2078:  CLRF   xF1
207A:  MOVLW  70
207C:  MOVWF  xF0
207E:  MOVLW  82
2080:  MOVWF  xEF
2082:  MOVLB  0
2084:  RCALL  1D66
2086:  BNC   2110
2088:  MOVFF  207,2EE
208C:  MOVFF  206,2ED
2090:  MOVFF  205,2EC
2094:  MOVFF  204,2EB
2098:  MOVLW  9A
209A:  MOVLB  2
209C:  MOVWF  xF2
209E:  MOVLW  99
20A0:  MOVWF  xF1
20A2:  MOVLW  19
20A4:  MOVWF  xF0
20A6:  MOVLW  7D
20A8:  MOVWF  xEF
20AA:  MOVLB  0
20AC:  RCALL  1D66
20AE:  BNC   2110
....................    { 
....................       if(Tpulso<9.0) 
20B0:  MOVFF  26B,2EE
20B4:  MOVFF  26A,2ED
20B8:  MOVFF  269,2EC
20BC:  MOVFF  268,2EB
20C0:  MOVLB  2
20C2:  CLRF   xF2
20C4:  CLRF   xF1
20C6:  MOVLW  10
20C8:  MOVWF  xF0
20CA:  MOVLW  82
20CC:  MOVWF  xEF
20CE:  MOVLB  0
20D0:  RCALL  1D66
20D2:  BNC   2110
....................       { 
....................          if(TiempoControl>=20) 
20D4:  MOVLB  2
20D6:  MOVF   x12,W
20D8:  SUBLW  13
20DA:  BC    2112
....................          { 
....................             TiempoControl=0; 
20DC:  CLRF   x12
....................             Ganancia+=2; 
20DE:  BCF    FD8.1
20E0:  MOVFF  27F,2F6
20E4:  MOVFF  27E,2F5
20E8:  MOVFF  27D,2F4
20EC:  MOVFF  27C,2F3
20F0:  CLRF   xFA
20F2:  CLRF   xF9
20F4:  CLRF   xF8
20F6:  MOVLW  80
20F8:  MOVWF  xF7
20FA:  MOVLB  0
20FC:  CALL   135C
2100:  MOVFF  03,27F
2104:  MOVFF  02,27E
2108:  MOVFF  01,27D
210C:  MOVFF  00,27C
2110:  MOVLB  2
....................          } 
....................       } 
....................    } 
....................     
....................    if(error<-0.3) 
2112:  MOVFF  26F,2EE
2116:  MOVFF  26E,2ED
211A:  MOVFF  26D,2EC
211E:  MOVFF  26C,2EB
2122:  MOVLW  9A
2124:  MOVWF  xF2
2126:  MOVLW  99
2128:  MOVWF  xF1
212A:  MOVWF  xF0
212C:  MOVLW  7D
212E:  MOVWF  xEF
2130:  MOVLB  0
2132:  RCALL  1D66
2134:  BNC   2146
....................    { 
....................       Ganancia=Ganancia2; 
2136:  MOVFF  283,27F
213A:  MOVFF  282,27E
213E:  MOVFF  281,27D
2142:  MOVFF  280,27C
....................    } 
....................     
....................    if(Ganancia<1) 
2146:  MOVFF  27F,2EE
214A:  MOVFF  27E,2ED
214E:  MOVFF  27D,2EC
2152:  MOVFF  27C,2EB
2156:  MOVLB  2
2158:  CLRF   xF2
215A:  CLRF   xF1
215C:  CLRF   xF0
215E:  MOVLW  7F
2160:  MOVWF  xEF
2162:  MOVLB  0
2164:  RCALL  1D66
2166:  BNC   2174
....................    { 
....................       Ganancia=1; 
2168:  MOVLB  2
216A:  CLRF   x7F
216C:  CLRF   x7E
216E:  CLRF   x7D
2170:  MOVLW  7F
2172:  MOVWF  x7C
....................    } 
....................     
....................    if(error<0.0)     // Anti Wind_DOWN     
2174:  MOVFF  26F,2EE
2178:  MOVFF  26E,2ED
217C:  MOVFF  26D,2EC
2180:  MOVFF  26C,2EB
2184:  MOVLB  2
2186:  CLRF   xF2
2188:  CLRF   xF1
218A:  CLRF   xF0
218C:  CLRF   xEF
218E:  MOVLB  0
2190:  RCALL  1D66
2192:  BNC   21A0
....................    { 
....................       error=0.0; 
2194:  MOVLB  2
2196:  CLRF   x6F
2198:  CLRF   x6E
219A:  CLRF   x6D
219C:  CLRF   x6C
219E:  MOVLB  0
....................    } 
....................    //tmp=(Setpoint-Prom)*Ganancia;  // Control Proporcional. 
....................    tmp=error*Ganancia;  // Control Proporcional. 
21A0:  MOVFF  26F,2F1
21A4:  MOVFF  26E,2F0
21A8:  MOVFF  26D,2EF
21AC:  MOVFF  26C,2EE
21B0:  MOVFF  27F,2F5
21B4:  MOVFF  27E,2F4
21B8:  MOVFF  27D,2F3
21BC:  MOVFF  27C,2F2
21C0:  RCALL  1BC0
21C2:  MOVFF  03,27B
21C6:  MOVFF  02,27A
21CA:  MOVFF  01,279
21CE:  MOVFF  00,278
....................           
....................    if(tmp>Setpoint)   // Anti Wind-UP       
21D2:  MOVFF  2AB,2EE
21D6:  MOVFF  2AA,2ED
21DA:  MOVFF  2A9,2EC
21DE:  MOVFF  2A8,2EB
21E2:  MOVFF  27B,2F2
21E6:  MOVFF  27A,2F1
21EA:  MOVFF  279,2F0
21EE:  MOVFF  278,2EF
21F2:  RCALL  1D66
21F4:  BNC   2206
....................    { 
....................       tmp=Setpoint; 
21F6:  MOVFF  2AB,27B
21FA:  MOVFF  2AA,27A
21FE:  MOVFF  2A9,279
2202:  MOVFF  2A8,278
....................    } 
....................                 
....................    if(tmp<0.0)     // Anti Wind_DOWN     
2206:  MOVFF  27B,2EE
220A:  MOVFF  27A,2ED
220E:  MOVFF  279,2EC
2212:  MOVFF  278,2EB
2216:  MOVLB  2
2218:  CLRF   xF2
221A:  CLRF   xF1
221C:  CLRF   xF0
221E:  CLRF   xEF
2220:  MOVLB  0
2222:  RCALL  1D66
2224:  BNC   2232
....................    { 
....................       tmp=0.0; 
2226:  MOVLB  2
2228:  CLRF   x7B
222A:  CLRF   x7A
222C:  CLRF   x79
222E:  CLRF   x78
2230:  MOVLB  0
....................    } 
....................     
....................    // Tpulso(t)= Tciclo*(y(t)-ymin)/(ymax - ymin); calculo de ciclo util para control de resistencia.ymax=140.ymin=0; 
....................    // Tpulso es float, hay que pasar ese ciclo a una salida de un puerto usando el TMR1. 
....................    Tpulso=(tmp/Setpoint)*Tciclo;   
2232:  MOVFF  27B,2F2
2236:  MOVFF  27A,2F1
223A:  MOVFF  279,2F0
223E:  MOVFF  278,2EF
2242:  MOVFF  2AB,2F6
2246:  MOVFF  2AA,2F5
224A:  MOVFF  2A9,2F4
224E:  MOVFF  2A8,2F3
2252:  CALL   11FE
2256:  MOVFF  00,2EA
225A:  MOVFF  01,2EB
225E:  MOVFF  02,2EC
2262:  MOVFF  03,2ED
2266:  MOVFF  03,2F1
226A:  MOVFF  02,2F0
226E:  MOVFF  01,2EF
2272:  MOVFF  00,2EE
2276:  MOVFF  267,2F5
227A:  MOVFF  266,2F4
227E:  MOVFF  265,2F3
2282:  MOVFF  264,2F2
2286:  RCALL  1BC0
2288:  MOVFF  03,26B
228C:  MOVFF  02,26A
2290:  MOVFF  01,269
2294:  MOVFF  00,268
....................                                        
....................    if(tiempoctrl<=(int16)(Tpulso/0.005)) // Si el tiempo es menor o igual al tiempo de control se enciende la resistencia de lo contrario se apaga. 
2298:  MOVFF  26B,2F2
229C:  MOVFF  26A,2F1
22A0:  MOVFF  269,2F0
22A4:  MOVFF  268,2EF
22A8:  MOVLW  0A
22AA:  MOVLB  2
22AC:  MOVWF  xF6
22AE:  MOVLW  D7
22B0:  MOVWF  xF5
22B2:  MOVLW  23
22B4:  MOVWF  xF4
22B6:  MOVLW  77
22B8:  MOVWF  xF3
22BA:  MOVLB  0
22BC:  CALL   11FE
22C0:  MOVFF  03,2ED
22C4:  MOVFF  02,2EC
22C8:  MOVFF  01,2EB
22CC:  MOVFF  00,2EA
22D0:  CALL   1112
22D4:  MOVFF  02,03
22D8:  MOVF   01,W
22DA:  MOVLB  2
22DC:  MOVF   x2E,W
22DE:  SUBWF  02,W
22E0:  BNC   22F0
22E2:  BNZ   22EA
22E4:  MOVF   x2D,W
22E6:  SUBWF  01,W
22E8:  BNC   22F0
....................    { 
....................       Resistencia_on; 
22EA:  BSF    F8A.0
22EC:  BCF    F93.0
....................    } 
....................    else          
22EE:  BRA    22F4
....................    { 
....................       Resistencia_off; 
22F0:  BCF    F8A.0
22F2:  BCF    F93.0
....................    } 
....................           
....................    if(tiempoctrl>=(int16)(Tciclo/0.005)) // Si el tiempo de control es mayor al tiempo de ciclo se reinicia tiempo de control 
22F4:  MOVFF  267,2F2
22F8:  MOVFF  266,2F1
22FC:  MOVFF  265,2F0
2300:  MOVFF  264,2EF
2304:  MOVLW  0A
2306:  MOVWF  xF6
2308:  MOVLW  D7
230A:  MOVWF  xF5
230C:  MOVLW  23
230E:  MOVWF  xF4
2310:  MOVLW  77
2312:  MOVWF  xF3
2314:  MOVLB  0
2316:  CALL   11FE
231A:  MOVFF  03,2ED
231E:  MOVFF  02,2EC
2322:  MOVFF  01,2EB
2326:  MOVFF  00,2EA
232A:  CALL   1112
232E:  MOVF   02,W
2330:  MOVWF  03
2332:  MOVLB  2
2334:  SUBWF  x2E,W
2336:  BNC   2344
2338:  BNZ   2340
233A:  MOVF   01,W
233C:  SUBWF  x2D,W
233E:  BNC   2344
....................    { 
....................       tiempoctrl=0; 
2340:  CLRF   x2E
2342:  CLRF   x2D
....................    } // tiempoctrl incrementa una unidad cada 5ms, por eso se dividen los tiempos por 0.005. 
.................... //--------------------------------------------------------------------------------------------------------------------//    
.................... } 
2344:  MOVLB  0
2346:  GOTO   3348 (RETURN)
....................  
.................... void main() 
.................... { 
*
23B6:  CLRF   FF8
23B8:  BCF    FD0.7
23BA:  BSF    07.7
23BC:  CLRF   FEA
23BE:  CLRF   FE9
23C0:  BSF    FB8.3
23C2:  MOVLW  87
23C4:  MOVWF  FAF
23C6:  MOVLW  13
23C8:  MOVWF  FB0
23CA:  MOVLW  A6
23CC:  MOVWF  FAC
23CE:  MOVLW  90
23D0:  MOVWF  FAB
23D2:  CLRF   22
23D4:  CLRF   26
23D6:  MOVLB  2
23D8:  CLRF   x03
23DA:  CLRF   x02
23DC:  CLRF   x01
23DE:  CLRF   x00
23E0:  CLRF   x07
23E2:  CLRF   x06
23E4:  CLRF   x05
23E6:  CLRF   x04
23E8:  BCF    x08.0
23EA:  BCF    x08.1
23EC:  BCF    x08.2
23EE:  BCF    x08.3
23F0:  BCF    x08.4
23F2:  BCF    x08.5
23F4:  BCF    x08.6
23F6:  BCF    x08.7
23F8:  BCF    x09.0
23FA:  MOVLW  01
23FC:  MOVWF  x0A
23FE:  CLRF   x0B
2400:  CLRF   x0C
2402:  CLRF   x0D
2404:  CLRF   x0E
2406:  CLRF   x0F
2408:  CLRF   x10
240A:  CLRF   x11
240C:  CLRF   x12
240E:  CLRF   x13
2410:  CLRF   x14
2412:  CLRF   x15
2414:  CLRF   x16
2416:  CLRF   x17
2418:  CLRF   x18
241A:  CLRF   x19
241C:  CLRF   x1A
241E:  CLRF   x1B
2420:  CLRF   x1C
2422:  CLRF   x1D
2424:  CLRF   x1E
2426:  CLRF   x1F
2428:  CLRF   x20
242A:  CLRF   x21
242C:  CLRF   x22
242E:  CLRF   x23
2430:  CLRF   x24
2432:  CLRF   x25
2434:  CLRF   x26
2436:  CLRF   x27
2438:  CLRF   x28
243A:  CLRF   x2A
243C:  CLRF   x29
243E:  CLRF   x2C
2440:  CLRF   x2B
2442:  CLRF   x2E
2444:  CLRF   x2D
2446:  CLRF   x30
2448:  MOVLW  0F
244A:  MOVWF  x2F
244C:  CLRF   x32
244E:  CLRF   x31
2450:  CLRF   x34
2452:  CLRF   x33
2454:  CLRF   x36
2456:  CLRF   x35
2458:  CLRF   x38
245A:  CLRF   x37
245C:  CLRF   x3A
245E:  CLRF   x39
2460:  BCF    x09.1
2462:  BCF    x09.2
2464:  BCF    x09.3
2466:  BCF    x09.4
2468:  BCF    x09.5
246A:  BCF    x09.6
246C:  BCF    x09.7
246E:  BCF    x3B.0
2470:  BCF    x3B.1
2472:  BCF    x3B.2
2474:  BCF    x3B.3
2476:  BCF    x3B.4
2478:  BCF    x3B.5
247A:  BCF    x3B.6
247C:  CLRF   x4C
247E:  CLRF   x4D
2480:  CLRF   x4E
2482:  CLRF   x4F
2484:  CLRF   x50
2486:  CLRF   x51
2488:  CLRF   x52
248A:  CLRF   x53
248C:  CLRF   x54
248E:  CLRF   x55
2490:  CLRF   x56
2492:  MOVLW  02
2494:  MOVWF  x57
2496:  CLRF   x5B
2498:  CLRF   x5A
249A:  CLRF   x59
249C:  CLRF   x58
249E:  CLRF   x5F
24A0:  MOVLW  40
24A2:  MOVWF  x5E
24A4:  MOVLW  1C
24A6:  MOVWF  x5D
24A8:  MOVLW  8C
24AA:  MOVWF  x5C
24AC:  CLRF   x67
24AE:  CLRF   x66
24B0:  MOVLW  20
24B2:  MOVWF  x65
24B4:  MOVLW  82
24B6:  MOVWF  x64
24B8:  CLRF   x6B
24BA:  CLRF   x6A
24BC:  CLRF   x69
24BE:  CLRF   x68
24C0:  CLRF   x6F
24C2:  CLRF   x6E
24C4:  CLRF   x6D
24C6:  CLRF   x6C
24C8:  CLRF   x73
24CA:  CLRF   x72
24CC:  CLRF   x71
24CE:  CLRF   x70
24D0:  CLRF   x77
24D2:  CLRF   x76
24D4:  CLRF   x75
24D6:  CLRF   x74
24D8:  CLRF   x7B
24DA:  CLRF   x7A
24DC:  CLRF   x79
24DE:  CLRF   x78
24E0:  CLRF   x7F
24E2:  CLRF   x7E
24E4:  MOVLW  48
24E6:  MOVWF  x7D
24E8:  MOVLW  83
24EA:  MOVWF  x7C
24EC:  CLRF   x83
24EE:  CLRF   x82
24F0:  MOVLW  20
24F2:  MOVWF  x81
24F4:  MOVLW  83
24F6:  MOVWF  x80
24F8:  CLRF   x87
24FA:  CLRF   x86
24FC:  CLRF   x85
24FE:  CLRF   x84
2500:  CLRF   x8B
2502:  CLRF   x8A
2504:  CLRF   x89
2506:  CLRF   x88
2508:  CLRF   x8F
250A:  CLRF   x8E
250C:  CLRF   x8D
250E:  CLRF   x8C
2510:  CLRF   x93
2512:  CLRF   x92
2514:  CLRF   x91
2516:  CLRF   x90
2518:  CLRF   x97
251A:  CLRF   x96
251C:  CLRF   x95
251E:  CLRF   x94
2520:  CLRF   x9B
2522:  CLRF   x9A
2524:  CLRF   x99
2526:  CLRF   x98
2528:  CLRF   x9F
252A:  CLRF   x9E
252C:  CLRF   x9D
252E:  CLRF   x9C
2530:  CLRF   xA3
2532:  CLRF   xA2
2534:  CLRF   xA1
2536:  CLRF   xA0
2538:  CLRF   xA7
253A:  CLRF   xA6
253C:  CLRF   xA5
253E:  CLRF   xA4
2540:  CLRF   xAB
2542:  CLRF   xAA
2544:  CLRF   xA9
2546:  CLRF   xA8
2548:  CLRF   xAF
254A:  CLRF   xAE
254C:  CLRF   xAD
254E:  CLRF   xAC
2550:  CLRF   xB3
2552:  CLRF   xB2
2554:  CLRF   xB1
2556:  CLRF   xB0
2558:  CLRF   xB7
255A:  CLRF   xB6
255C:  CLRF   xB5
255E:  CLRF   xB4
2560:  MOVLW  5C
2562:  MOVWF  xBB
2564:  MOVLW  AA
2566:  MOVWF  xBA
2568:  MOVLW  52
256A:  MOVWF  xB9
256C:  MOVLW  77
256E:  MOVWF  xB8
2570:  MOVF   FC1,W
2572:  ANDLW  C0
2574:  IORLW  0F
2576:  MOVWF  FC1
2578:  MOVLW  07
257A:  MOVWF  FB4
257C:  CLRF   17
257E:  CLRF   18
2580:  MOVLB  0
2582:  CLRF   x68
2584:  CLRF   x69
2586:  CLRF   x6A
2588:  CLRF   x6B
258A:  CLRF   x6C
258C:  CLRF   x6D
258E:  CLRF   x6E
2590:  CLRF   x6F
2592:  CLRF   x70
2594:  CLRF   x71
2596:  CLRF   x72
2598:  CLRF   x73
259A:  CLRF   x74
259C:  CLRF   x75
259E:  CLRF   x76
25A0:  CLRF   x77
25A2:  CLRF   x78
25A4:  CLRF   x79
25A6:  CLRF   x7A
25A8:  CLRF   x7B
25AA:  CLRF   x7C
25AC:  CLRF   x7D
25AE:  CLRF   x7E
25B0:  CLRF   x7F
25B2:  CLRF   x80
25B4:  CLRF   x81
25B6:  CLRF   x82
25B8:  CLRF   x83
25BA:  CLRF   x84
25BC:  CLRF   x85
25BE:  CLRF   x86
25C0:  CLRF   x87
25C2:  CLRF   x88
25C4:  CLRF   x89
25C6:  CLRF   x8A
25C8:  CLRF   x8B
25CA:  CLRF   x8C
25CC:  CLRF   x8D
25CE:  CLRF   x8E
25D0:  CLRF   x8F
25D2:  CLRF   x90
25D4:  CLRF   x91
25D6:  CLRF   x92
25D8:  CLRF   x93
25DA:  CLRF   x94
25DC:  CLRF   x95
25DE:  CLRF   x96
25E0:  CLRF   x97
25E2:  CLRF   x98
25E4:  CLRF   x99
25E6:  CLRF   x9A
25E8:  CLRF   x9B
25EA:  CLRF   x9C
25EC:  CLRF   x9D
25EE:  CLRF   x9E
25F0:  CLRF   x9F
25F2:  CLRF   xA0
25F4:  CLRF   xA1
25F6:  CLRF   xA2
25F8:  CLRF   xA3
25FA:  CLRF   xA4
25FC:  CLRF   xA5
25FE:  CLRF   xA6
2600:  CLRF   xA7
2602:  CLRF   xA8
2604:  CLRF   xA9
2606:  CLRF   xAA
2608:  CLRF   xAB
260A:  CLRF   xAC
260C:  CLRF   xAD
260E:  CLRF   xAE
2610:  CLRF   xAF
2612:  CLRF   xB0
2614:  CLRF   xB1
2616:  CLRF   xB2
2618:  CLRF   xB3
261A:  CLRF   xB4
261C:  CLRF   xB5
261E:  CLRF   xB6
2620:  CLRF   xB7
2622:  CLRF   xB8
2624:  CLRF   xB9
2626:  CLRF   xBA
2628:  CLRF   xBB
262A:  CLRF   xBC
262C:  CLRF   xBD
262E:  CLRF   xBE
2630:  CLRF   xBF
2632:  CLRF   xC0
2634:  CLRF   xC1
2636:  CLRF   xC2
2638:  CLRF   xC3
263A:  CLRF   xC4
263C:  CLRF   xC5
263E:  CLRF   xC6
2640:  CLRF   xC7
2642:  CLRF   xC8
2644:  CLRF   xC9
2646:  CLRF   xCA
2648:  CLRF   xCB
264A:  CLRF   xCC
264C:  CLRF   xCD
264E:  CLRF   xCE
2650:  CLRF   xCF
2652:  CLRF   xD0
2654:  CLRF   xD1
2656:  CLRF   xD2
2658:  CLRF   xD3
265A:  CLRF   xD4
265C:  CLRF   xD5
265E:  CLRF   xD6
2660:  CLRF   xD7
2662:  CLRF   xD8
2664:  CLRF   xD9
2666:  CLRF   xDA
2668:  CLRF   xDB
266A:  CLRF   xDC
266C:  CLRF   xDD
266E:  CLRF   xDE
2670:  CLRF   xDF
2672:  CLRF   xE0
2674:  CLRF   xE1
2676:  CLRF   xE2
2678:  CLRF   xE3
267A:  CLRF   xE4
267C:  CLRF   xE5
267E:  CLRF   xE6
2680:  CLRF   xE7
2682:  CLRF   xE8
2684:  CLRF   xE9
2686:  CLRF   xEA
2688:  CLRF   xEB
268A:  CLRF   xEC
268C:  CLRF   xED
268E:  CLRF   xEE
2690:  CLRF   xEF
2692:  CLRF   xF0
2694:  CLRF   xF1
2696:  CLRF   xF2
2698:  CLRF   xF3
269A:  CLRF   xF4
269C:  CLRF   xF5
269E:  CLRF   xF6
26A0:  CLRF   xF7
26A2:  CLRF   xF8
26A4:  CLRF   xF9
26A6:  CLRF   xFA
26A8:  CLRF   xFB
26AA:  CLRF   xFC
26AC:  CLRF   xFD
26AE:  CLRF   xFE
26B0:  CLRF   xFF
26B2:  MOVLB  1
26B4:  CLRF   x00
26B6:  CLRF   x01
26B8:  CLRF   x02
26BA:  CLRF   x03
26BC:  CLRF   x04
26BE:  CLRF   x05
26C0:  CLRF   x06
26C2:  CLRF   x07
26C4:  CLRF   x08
26C6:  CLRF   x09
26C8:  CLRF   x0A
26CA:  CLRF   x0B
26CC:  CLRF   x0C
26CE:  CLRF   x0D
26D0:  CLRF   x0E
26D2:  CLRF   x0F
26D4:  CLRF   x10
26D6:  CLRF   x11
26D8:  CLRF   x12
26DA:  CLRF   x13
26DC:  CLRF   x14
26DE:  CLRF   x15
26E0:  CLRF   x16
26E2:  CLRF   x17
26E4:  CLRF   x18
26E6:  CLRF   x19
26E8:  CLRF   x1A
26EA:  CLRF   x1B
26EC:  CLRF   x1C
26EE:  CLRF   x1D
26F0:  CLRF   x1E
26F2:  CLRF   x1F
26F4:  CLRF   x20
26F6:  CLRF   x21
26F8:  CLRF   x22
26FA:  CLRF   x23
26FC:  CLRF   x24
26FE:  CLRF   x25
2700:  CLRF   x26
2702:  CLRF   x27
2704:  CLRF   x28
2706:  CLRF   x29
2708:  CLRF   x2A
270A:  CLRF   x2B
270C:  CLRF   x2C
270E:  CLRF   x2D
2710:  CLRF   x2E
2712:  CLRF   x2F
2714:  CLRF   x30
2716:  CLRF   x31
2718:  CLRF   x32
271A:  CLRF   x33
271C:  CLRF   x34
271E:  CLRF   x35
2720:  CLRF   x36
2722:  CLRF   x37
2724:  CLRF   x38
2726:  CLRF   x39
2728:  CLRF   x3A
272A:  CLRF   x3B
272C:  CLRF   x3C
272E:  CLRF   x3D
2730:  CLRF   x3E
2732:  CLRF   x3F
2734:  CLRF   x40
2736:  CLRF   x41
2738:  CLRF   x42
273A:  CLRF   x43
273C:  CLRF   x44
273E:  CLRF   x45
2740:  CLRF   x46
2742:  CLRF   x47
2744:  CLRF   x48
2746:  CLRF   x49
2748:  CLRF   x4A
274A:  CLRF   x4B
274C:  CLRF   x4C
274E:  CLRF   x4D
2750:  CLRF   x4E
2752:  CLRF   x4F
2754:  CLRF   x50
2756:  CLRF   x51
2758:  CLRF   x52
275A:  CLRF   x53
275C:  CLRF   x54
275E:  CLRF   x55
2760:  CLRF   x56
2762:  CLRF   x57
2764:  CLRF   x58
2766:  CLRF   x59
2768:  CLRF   x5A
276A:  CLRF   x5B
276C:  CLRF   x5C
276E:  CLRF   x5D
2770:  CLRF   x5E
2772:  CLRF   x5F
2774:  CLRF   x60
2776:  CLRF   x61
2778:  CLRF   x62
277A:  CLRF   x63
277C:  CLRF   x64
277E:  CLRF   x65
2780:  CLRF   x66
2782:  CLRF   x67
2784:  CLRF   x68
2786:  CLRF   x69
2788:  CLRF   x6A
278A:  CLRF   x6B
278C:  CLRF   x6C
278E:  CLRF   x6D
2790:  CLRF   x6E
2792:  CLRF   x6F
2794:  CLRF   x70
2796:  CLRF   x71
2798:  CLRF   x72
279A:  CLRF   x73
279C:  CLRF   x74
279E:  CLRF   x75
27A0:  CLRF   x76
27A2:  CLRF   x77
27A4:  CLRF   x78
27A6:  CLRF   x79
27A8:  CLRF   x7A
27AA:  CLRF   x7B
27AC:  CLRF   x7C
27AE:  CLRF   x7D
27B0:  CLRF   x7E
27B2:  CLRF   x7F
27B4:  CLRF   x80
27B6:  CLRF   x81
27B8:  CLRF   x82
27BA:  CLRF   x83
27BC:  CLRF   x84
27BE:  CLRF   x85
27C0:  CLRF   x86
27C2:  CLRF   x87
27C4:  CLRF   x88
27C6:  CLRF   x89
27C8:  CLRF   x8A
27CA:  CLRF   x8B
27CC:  CLRF   x8C
27CE:  CLRF   x8D
27D0:  CLRF   x8E
27D2:  CLRF   x8F
27D4:  CLRF   x90
27D6:  CLRF   x91
27D8:  CLRF   x92
27DA:  CLRF   x93
27DC:  CLRF   x94
27DE:  CLRF   x95
27E0:  CLRF   x96
27E2:  CLRF   x97
27E4:  CLRF   x98
27E6:  CLRF   x99
27E8:  CLRF   x9A
27EA:  CLRF   x9B
27EC:  CLRF   x9C
27EE:  CLRF   x9D
27F0:  CLRF   x9E
27F2:  CLRF   x9F
27F4:  CLRF   xA0
27F6:  CLRF   xA1
27F8:  CLRF   xA2
27FA:  CLRF   xA3
27FC:  CLRF   xA4
27FE:  CLRF   xA5
2800:  CLRF   xA6
2802:  CLRF   xA7
2804:  CLRF   xA8
2806:  CLRF   xA9
2808:  CLRF   xAA
280A:  CLRF   xAB
280C:  CLRF   xAC
280E:  CLRF   xAD
2810:  CLRF   xAE
2812:  CLRF   xAF
2814:  CLRF   xB0
2816:  CLRF   xB1
2818:  CLRF   xB2
281A:  CLRF   xB3
281C:  CLRF   xB4
281E:  CLRF   xB5
2820:  CLRF   xB6
2822:  CLRF   xB7
2824:  CLRF   xB8
2826:  CLRF   xB9
2828:  CLRF   xBA
282A:  CLRF   xBB
282C:  CLRF   xBC
282E:  CLRF   xBD
2830:  CLRF   xBE
2832:  CLRF   xBF
2834:  CLRF   xC0
2836:  CLRF   xC1
2838:  CLRF   xC2
283A:  CLRF   xC3
283C:  CLRF   xC4
283E:  CLRF   xC5
2840:  CLRF   xC6
2842:  CLRF   xC7
2844:  CLRF   xC8
2846:  CLRF   xC9
2848:  CLRF   xCA
284A:  CLRF   xCB
284C:  CLRF   xCC
284E:  CLRF   xCD
2850:  CLRF   xCE
2852:  CLRF   xCF
2854:  CLRF   xD0
2856:  CLRF   xD1
2858:  CLRF   xD2
285A:  CLRF   xD3
285C:  CLRF   xD4
285E:  CLRF   xD5
2860:  CLRF   xD6
2862:  CLRF   xD7
2864:  CLRF   xD8
2866:  CLRF   xD9
2868:  CLRF   xDA
286A:  CLRF   xDB
286C:  CLRF   xDC
286E:  CLRF   xDD
2870:  CLRF   xDE
2872:  CLRF   xDF
2874:  CLRF   xE0
2876:  CLRF   xE1
2878:  CLRF   xE2
287A:  CLRF   xE3
287C:  CLRF   xE4
287E:  CLRF   xE5
2880:  CLRF   xE6
2882:  CLRF   xE7
2884:  CLRF   xE8
2886:  CLRF   xE9
2888:  CLRF   xEA
288A:  CLRF   xEB
288C:  CLRF   xEC
288E:  CLRF   xED
2890:  CLRF   xEE
2892:  CLRF   xEF
2894:  CLRF   xF0
2896:  CLRF   xF1
2898:  CLRF   xF2
289A:  CLRF   xF3
289C:  CLRF   xF4
289E:  CLRF   xF5
28A0:  CLRF   xF6
28A2:  CLRF   xF7
28A4:  CLRF   xF8
28A6:  CLRF   xF9
28A8:  CLRF   xFA
28AA:  CLRF   xFB
28AC:  CLRF   xFC
28AE:  CLRF   xFD
28B0:  CLRF   xFE
28B2:  CLRF   xFF
28B4:  MOVLB  2
28B6:  CLRF   x3C
28B8:  CLRF   x3D
28BA:  CLRF   x3E
28BC:  CLRF   x3F
28BE:  CLRF   x40
28C0:  CLRF   x41
28C2:  CLRF   x42
28C4:  CLRF   x43
28C6:  CLRF   x44
28C8:  CLRF   x45
28CA:  CLRF   x46
28CC:  CLRF   x47
28CE:  CLRF   x48
28D0:  CLRF   x49
28D2:  CLRF   x4A
28D4:  CLRF   x4B
28D6:  CLRF   xE7
28D8:  CLRF   xE8
28DA:  CLRF   xE9
....................    output_b(0); 
28DC:  CLRF   F93
28DE:  CLRF   F8A
....................    delay_ms(1000); 
28E0:  MOVLW  04
28E2:  MOVWF  xEA
28E4:  MOVLW  FA
28E6:  MOVWF  xF0
28E8:  MOVLB  0
28EA:  CALL   0FDE
28EE:  MOVLB  2
28F0:  DECFSZ xEA,F
28F2:  BRA    28E4
....................    enable_interrupts(INT_RDA);      //Habilita interrupción por recepción RS23    
28F4:  BSF    F9D.5
....................    enable_interrupts(global); 
28F6:  MOVLW  C0
28F8:  IORWF  FF2,F
....................     
....................     
....................    setup_timer_0(RTCC_8_BIT|RTCC_DIV_1); 
28FA:  MOVLW  C8
28FC:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0); 
28FE:  BSF    FF2.5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
2900:  MOVLW  85
2902:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1); 
2904:  BSF    F9D.0
....................    setup_adc_ports(AN0_TO_AN3); 
2906:  MOVF   FC1,W
2908:  ANDLW  C0
290A:  IORLW  0B
290C:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_32 ); 
290E:  BCF    FC0.0
2910:  BSF    FC0.1
2912:  BCF    FC0.2
2914:  BSF    FC0.7
2916:  BSF    FC2.0
....................    sensores(0); 
2918:  CLRF   xEB
291A:  MOVLB  0
291C:  CALL   103E
....................    Ganancia=read_eeprom(10);desvio=read_eeprom(11);Tciclo=read_eeprom(12); 
2920:  MOVFF  FF2,2EA
2924:  BCF    FF2.7
2926:  MOVLW  0A
2928:  MOVWF  FA9
292A:  BCF    FA6.6
292C:  BCF    FA6.7
292E:  BSF    FA6.0
2930:  MOVF   FA8,W
2932:  MOVLB  2
2934:  BTFSC  xEA.7
2936:  BSF    FF2.7
2938:  CLRF   xF1
293A:  MOVWF  xF0
293C:  MOVLB  0
293E:  CALL   1008
2942:  MOVFF  03,27F
2946:  MOVFF  02,27E
294A:  MOVFF  01,27D
294E:  MOVFF  00,27C
2952:  MOVFF  FF2,2EA
2956:  BCF    FF2.7
2958:  MOVLW  0B
295A:  MOVWF  FA9
295C:  BCF    FA6.6
295E:  BCF    FA6.7
2960:  BSF    FA6.0
2962:  MOVF   FA8,W
2964:  MOVLB  2
2966:  BTFSC  xEA.7
2968:  BSF    FF2.7
296A:  CLRF   xF1
296C:  MOVWF  xF0
296E:  MOVLB  0
2970:  CALL   1008
2974:  MOVFF  03,287
2978:  MOVFF  02,286
297C:  MOVFF  01,285
2980:  MOVFF  00,284
2984:  MOVFF  FF2,2EA
2988:  BCF    FF2.7
298A:  MOVLW  0C
298C:  MOVWF  FA9
298E:  BCF    FA6.6
2990:  BCF    FA6.7
2992:  BSF    FA6.0
2994:  MOVF   FA8,W
2996:  MOVLB  2
2998:  BTFSC  xEA.7
299A:  BSF    FF2.7
299C:  CLRF   xF1
299E:  MOVWF  xF0
29A0:  MOVLB  0
29A2:  CALL   1008
29A6:  MOVFF  03,267
29AA:  MOVFF  02,266
29AE:  MOVFF  01,265
29B2:  MOVFF  00,264
....................    Ajuste=read_eeprom(13);Ajusten=read_eeprom(14);Ganancia2=read_eeprom(15); 
29B6:  MOVFF  FF2,2EA
29BA:  BCF    FF2.7
29BC:  MOVLW  0D
29BE:  MOVWF  FA9
29C0:  BCF    FA6.6
29C2:  BCF    FA6.7
29C4:  BSF    FA6.0
29C6:  MOVF   FA8,W
29C8:  MOVLB  2
29CA:  BTFSC  xEA.7
29CC:  BSF    FF2.7
29CE:  MOVWF  x4E
29D0:  MOVFF  FF2,2EA
29D4:  BCF    FF2.7
29D6:  MOVLW  0E
29D8:  MOVWF  FA9
29DA:  BCF    FA6.6
29DC:  BCF    FA6.7
29DE:  BSF    FA6.0
29E0:  MOVF   FA8,W
29E2:  BTFSC  xEA.7
29E4:  BSF    FF2.7
29E6:  MOVWF  x4F
29E8:  MOVFF  FF2,2EA
29EC:  BCF    FF2.7
29EE:  MOVLW  0F
29F0:  MOVWF  FA9
29F2:  BCF    FA6.6
29F4:  BCF    FA6.7
29F6:  BSF    FA6.0
29F8:  MOVF   FA8,W
29FA:  BTFSC  xEA.7
29FC:  BSF    FF2.7
29FE:  CLRF   xF1
2A00:  MOVWF  xF0
2A02:  MOVLB  0
2A04:  CALL   1008
2A08:  MOVFF  03,283
2A0C:  MOVFF  02,282
2A10:  MOVFF  01,281
2A14:  MOVFF  00,280
....................    MediaMovil=read_eeprom(20); 
2A18:  MOVFF  FF2,2EA
2A1C:  BCF    FF2.7
2A1E:  MOVLW  14
2A20:  MOVWF  FA9
2A22:  BCF    FA6.6
2A24:  BCF    FA6.7
2A26:  BSF    FA6.0
2A28:  MOVF   FA8,W
2A2A:  MOVLB  2
2A2C:  BTFSC  xEA.7
2A2E:  BSF    FF2.7
2A30:  MOVWF  x57
....................    EV_Agua_off;EV_Trampa_off;EV_Desfogue_off;Resistencia_off; 
2A32:  BCF    F8A.2
2A34:  BCF    F93.2
2A36:  BCF    F8A.3
2A38:  BCF    F93.3
2A3A:  BCF    F8A.1
2A3C:  BCF    F93.1
2A3E:  BCF    F8A.0
2A40:  BCF    F93.0
....................    usb_init(); 
2A42:  MOVLB  0
2A44:  GOTO   1104
....................    usb_task(); 
2A48:  CALL   10E2
....................    Puerta=0;Parada=0;NivelReservorio=0;NivelTanque=0;Presostato=0;ADC_Pt100=0; 
2A4C:  MOVLB  2
2A4E:  CLRF   x21
2A50:  CLRF   x22
2A52:  CLRF   x23
2A54:  CLRF   x24
2A56:  CLRF   x25
2A58:  CLRF   x26
....................    EnviarCodigo(); 
2A5A:  MOVLB  0
2A5C:  CALL   1158
....................    tiempo_esterilizacion=0; 
2A60:  MOVLB  2
2A62:  CLRF   x53
....................    for(z=0;z<40;z++) 
2A64:  CLRF   x14
2A66:  MOVF   x14,W
2A68:  SUBLW  27
2A6A:  BNC   2A8C
....................    { 
....................       Temperatura=Leer_Sensor(MediaMovil); 
2A6C:  MOVFF  257,2EA
2A70:  MOVLB  0
2A72:  CALL   16F4
2A76:  MOVFF  03,2AF
2A7A:  MOVFF  02,2AE
2A7E:  MOVFF  01,2AD
2A82:  MOVFF  00,2AC
....................    } 
2A86:  MOVLB  2
2A88:  INCF   x14,F
2A8A:  BRA    2A66
....................    EV_Agua_off; 
2A8C:  BCF    F8A.2
2A8E:  BCF    F93.2
....................    
.................... while(true) 
.................... { 
....................    if(STOP || Visua==1) 
2A90:  BSF    F95.4
2A92:  BTFSS  F83.4
2A94:  BRA    2A9A
2A96:  BTFSS  x3B.5
2A98:  BRA    2AB2
....................    { 
....................       emergency=1; 
2A9A:  BSF    x08.0
....................       EV_Desfogue_on; 
2A9C:  BSF    F8A.1
2A9E:  BCF    F93.1
....................       EV_in_Agua_off; 
2AA0:  BCF    F8A.4
2AA2:  BCF    F93.4
....................       EV_Agua_off; 
2AA4:  BCF    F8A.2
2AA6:  BCF    F93.2
....................       Resistencia_off; 
2AA8:  BCF    F8A.0
2AAA:  BCF    F93.0
....................       EVDesfogue=0; 
2AAC:  CLRF   x16
....................       disable_interrupts(INT_TIMER0); 
2AAE:  BCF    FF2.5
....................    }         
....................    else 
2AB0:  BRA    2ACA
....................    { 
....................       if(emergency==1) 
2AB2:  BTFSS  x08.0
2AB4:  BRA    2ACA
....................       { 
....................          delay_ms(1500); 
2AB6:  MOVLW  06
2AB8:  MOVWF  xEA
2ABA:  MOVLW  FA
2ABC:  MOVWF  xF0
2ABE:  MOVLB  0
2AC0:  CALL   0FDE
2AC4:  MOVLB  2
2AC6:  DECFSZ xEA,F
2AC8:  BRA    2ABA
....................       } 
....................    } 
....................     
.................... //_Menu_De_USB--------------------------------------------------------------------------------------------------------------------------------------------     
.................... if(usb_enumerated()) 
2ACA:  MOVLB  0
2ACC:  GOTO   1A68
2AD0:  MOVF   01,F
2AD2:  BTFSC  FD8.2
2AD4:  BRA    3212
.................... { 
....................    if(usb_kbhit(1)) 
2AD6:  MOVLW  01
2AD8:  MOVLB  2
2ADA:  MOVWF  xEA
2ADC:  MOVLB  0
2ADE:  GOTO   1A70
2AE2:  MOVF   01,F
2AE4:  BTFSC  FD8.2
2AE6:  BRA    2D3E
....................    { 
....................       usb_get_packet(1, rxbuf, Lenbuf); 
2AE8:  MOVLW  01
2AEA:  MOVLB  2
2AEC:  MOVWF  xEA
2AEE:  CLRF   xEC
2AF0:  MOVLW  48
2AF2:  MOVWF  xEB
2AF4:  CLRF   xEE
2AF6:  MOVLW  20
2AF8:  MOVWF  xED
2AFA:  MOVLB  0
2AFC:  GOTO   1B76
....................       if(rxbuf[0]==1) 
2B00:  DECFSZ 48,W
2B02:  BRA    2B8C
....................       { 
....................          Ganancia=rxbuf[1];desvio=rxbuf[2];Tciclo=rxbuf[3];MediaMovil=rxbuf[5];Ganancia2=rxbuf[6];Ajuste=rxbuf[7]; 
2B04:  MOVLB  2
2B06:  CLRF   xF1
2B08:  MOVFF  49,2F0
2B0C:  MOVLB  0
2B0E:  CALL   1008
2B12:  MOVFF  03,27F
2B16:  MOVFF  02,27E
2B1A:  MOVFF  01,27D
2B1E:  MOVFF  00,27C
2B22:  MOVLB  2
2B24:  CLRF   xF1
2B26:  MOVFF  4A,2F0
2B2A:  MOVLB  0
2B2C:  CALL   1008
2B30:  MOVFF  03,287
2B34:  MOVFF  02,286
2B38:  MOVFF  01,285
2B3C:  MOVFF  00,284
2B40:  MOVLB  2
2B42:  CLRF   xF1
2B44:  MOVFF  4B,2F0
2B48:  MOVLB  0
2B4A:  CALL   1008
2B4E:  MOVFF  03,267
2B52:  MOVFF  02,266
2B56:  MOVFF  01,265
2B5A:  MOVFF  00,264
2B5E:  MOVFF  4D,257
2B62:  MOVLB  2
2B64:  CLRF   xF1
2B66:  MOVFF  4E,2F0
2B6A:  MOVLB  0
2B6C:  CALL   1008
2B70:  MOVFF  03,283
2B74:  MOVFF  02,282
2B78:  MOVFF  01,281
2B7C:  MOVFF  00,280
2B80:  MOVFF  4F,24E
....................          Ajusten=rxbuf[10];R2=rxbuf[11]; 
2B84:  MOVFF  52,24F
2B88:  MOVFF  53,250
....................       } // Falta escribir en la eeprom 
....................       if(rxbuf[12]==1)    
2B8C:  DECFSZ 54,W
2B8E:  BRA    2D18
....................       { 
....................          write_eeprom(10,(int8)Ganancia);write_eeprom(11,(int8)desvio);write_eeprom(12,(int8)Tciclo);write_eeprom(20,MediaMovil); 
2B90:  MOVFF  27F,2ED
2B94:  MOVFF  27E,2EC
2B98:  MOVFF  27D,2EB
2B9C:  MOVFF  27C,2EA
2BA0:  CALL   1112
2BA4:  MOVFF  01,2EA
2BA8:  MOVLW  0A
2BAA:  MOVWF  FA9
2BAC:  MOVFF  2EA,FA8
2BB0:  BCF    FA6.6
2BB2:  BCF    FA6.7
2BB4:  BSF    FA6.2
2BB6:  MOVF   FF2,W
2BB8:  MOVWF  00
2BBA:  BCF    FF2.7
2BBC:  MOVLB  F
2BBE:  MOVLW  55
2BC0:  MOVWF  FA7
2BC2:  MOVLW  AA
2BC4:  MOVWF  FA7
2BC6:  BSF    FA6.1
2BC8:  BTFSC  FA6.1
2BCA:  BRA    2BC8
2BCC:  BCF    FA6.2
2BCE:  MOVF   00,W
2BD0:  IORWF  FF2,F
2BD2:  MOVFF  287,2ED
2BD6:  MOVFF  286,2EC
2BDA:  MOVFF  285,2EB
2BDE:  MOVFF  284,2EA
2BE2:  MOVLB  0
2BE4:  CALL   1112
2BE8:  MOVFF  01,2EA
2BEC:  MOVLW  0B
2BEE:  MOVWF  FA9
2BF0:  MOVFF  2EA,FA8
2BF4:  BCF    FA6.6
2BF6:  BCF    FA6.7
2BF8:  BSF    FA6.2
2BFA:  MOVF   FF2,W
2BFC:  MOVWF  00
2BFE:  BCF    FF2.7
2C00:  MOVLB  F
2C02:  MOVLW  55
2C04:  MOVWF  FA7
2C06:  MOVLW  AA
2C08:  MOVWF  FA7
2C0A:  BSF    FA6.1
2C0C:  BTFSC  FA6.1
2C0E:  BRA    2C0C
2C10:  BCF    FA6.2
2C12:  MOVF   00,W
2C14:  IORWF  FF2,F
2C16:  MOVFF  267,2ED
2C1A:  MOVFF  266,2EC
2C1E:  MOVFF  265,2EB
2C22:  MOVFF  264,2EA
2C26:  MOVLB  0
2C28:  CALL   1112
2C2C:  MOVFF  01,2EA
2C30:  MOVLW  0C
2C32:  MOVWF  FA9
2C34:  MOVFF  2EA,FA8
2C38:  BCF    FA6.6
2C3A:  BCF    FA6.7
2C3C:  BSF    FA6.2
2C3E:  MOVF   FF2,W
2C40:  MOVWF  00
2C42:  BCF    FF2.7
2C44:  MOVLB  F
2C46:  MOVLW  55
2C48:  MOVWF  FA7
2C4A:  MOVLW  AA
2C4C:  MOVWF  FA7
2C4E:  BSF    FA6.1
2C50:  BTFSC  FA6.1
2C52:  BRA    2C50
2C54:  BCF    FA6.2
2C56:  MOVF   00,W
2C58:  IORWF  FF2,F
2C5A:  MOVLW  14
2C5C:  MOVWF  FA9
2C5E:  MOVFF  257,FA8
2C62:  BCF    FA6.6
2C64:  BCF    FA6.7
2C66:  BSF    FA6.2
2C68:  MOVF   FF2,W
2C6A:  MOVWF  00
2C6C:  BCF    FF2.7
2C6E:  MOVLW  55
2C70:  MOVWF  FA7
2C72:  MOVLW  AA
2C74:  MOVWF  FA7
2C76:  BSF    FA6.1
2C78:  BTFSC  FA6.1
2C7A:  BRA    2C78
2C7C:  BCF    FA6.2
2C7E:  MOVF   00,W
2C80:  IORWF  FF2,F
....................          write_eeprom(13,(int8)Ajuste);write_eeprom(14,(int8)Ajusten);write_eeprom(15,(int8)Ganancia2); 
2C82:  MOVLW  0D
2C84:  MOVWF  FA9
2C86:  MOVFF  24E,FA8
2C8A:  BCF    FA6.6
2C8C:  BCF    FA6.7
2C8E:  BSF    FA6.2
2C90:  MOVF   FF2,W
2C92:  MOVWF  00
2C94:  BCF    FF2.7
2C96:  MOVLW  55
2C98:  MOVWF  FA7
2C9A:  MOVLW  AA
2C9C:  MOVWF  FA7
2C9E:  BSF    FA6.1
2CA0:  BTFSC  FA6.1
2CA2:  BRA    2CA0
2CA4:  BCF    FA6.2
2CA6:  MOVF   00,W
2CA8:  IORWF  FF2,F
2CAA:  MOVLW  0E
2CAC:  MOVWF  FA9
2CAE:  MOVFF  24F,FA8
2CB2:  BCF    FA6.6
2CB4:  BCF    FA6.7
2CB6:  BSF    FA6.2
2CB8:  MOVF   FF2,W
2CBA:  MOVWF  00
2CBC:  BCF    FF2.7
2CBE:  MOVLW  55
2CC0:  MOVWF  FA7
2CC2:  MOVLW  AA
2CC4:  MOVWF  FA7
2CC6:  BSF    FA6.1
2CC8:  BTFSC  FA6.1
2CCA:  BRA    2CC8
2CCC:  BCF    FA6.2
2CCE:  MOVF   00,W
2CD0:  IORWF  FF2,F
2CD2:  MOVFF  283,2ED
2CD6:  MOVFF  282,2EC
2CDA:  MOVFF  281,2EB
2CDE:  MOVFF  280,2EA
2CE2:  MOVLB  0
2CE4:  CALL   1112
2CE8:  MOVFF  01,2EA
2CEC:  MOVLW  0F
2CEE:  MOVWF  FA9
2CF0:  MOVFF  2EA,FA8
2CF4:  BCF    FA6.6
2CF6:  BCF    FA6.7
2CF8:  BSF    FA6.2
2CFA:  MOVF   FF2,W
2CFC:  MOVWF  00
2CFE:  BCF    FF2.7
2D00:  MOVLB  F
2D02:  MOVLW  55
2D04:  MOVWF  FA7
2D06:  MOVLW  AA
2D08:  MOVWF  FA7
2D0A:  BSF    FA6.1
2D0C:  BTFSC  FA6.1
2D0E:  BRA    2D0C
2D10:  BCF    FA6.2
2D12:  MOVF   00,W
2D14:  IORWF  FF2,F
2D16:  MOVLB  0
....................       }   
....................        
....................       if(rxbuf[13]==1) 
2D18:  DECFSZ 55,W
2D1A:  BRA    2D24
....................       { 
....................          Visua=1; 
2D1C:  MOVLB  2
2D1E:  BSF    x3B.5
....................       } 
....................       else 
2D20:  BRA    2D28
2D22:  MOVLB  0
....................       { 
....................          Visua=0; 
2D24:  MOVLB  2
2D26:  BCF    x3B.5
....................       } 
....................        
....................       if(rxbuf[8]==1)// Camara OUT 
2D28:  DECFSZ 50,W
2D2A:  BRA    2D30
....................       { 
....................          CamaraOUT=1; 
2D2C:  BSF    x08.5
....................       } 
....................       else 
2D2E:  BRA    2D32
....................       { 
....................          CamaraOUT=0; 
2D30:  BCF    x08.5
....................       } 
....................        
....................       if(rxbuf[9]==1)// Camara IN 
2D32:  DECFSZ 51,W
2D34:  BRA    2D3A
....................       { 
....................          CamaraIN=1; 
2D36:  BSF    x08.6
....................       } 
....................       else 
2D38:  BRA    2D3C
....................       { 
....................          CamaraIN=0; 
2D3A:  BCF    x08.6
2D3C:  MOVLB  0
....................       } 
....................     } 
....................      
....................     TempUSB=Temperatura; 
2D3E:  MOVFF  2AF,2B3
2D42:  MOVFF  2AE,2B2
2D46:  MOVFF  2AD,2B1
2D4A:  MOVFF  2AC,2B0
....................     recbuf[0]=(int8)(TempUSB); 
2D4E:  MOVFF  2B3,2ED
2D52:  MOVFF  2B2,2EC
2D56:  MOVFF  2B1,2EB
2D5A:  MOVFF  2B0,2EA
2D5E:  CALL   1112
2D62:  MOVFF  01,28
....................     recbuf[1]=120; 
2D66:  MOVLW  78
2D68:  MOVWF  29
....................     d3=TempUSB-(int8)TempUSB; 
2D6A:  MOVFF  2B3,2ED
2D6E:  MOVFF  2B2,2EC
2D72:  MOVFF  2B1,2EB
2D76:  MOVFF  2B0,2EA
2D7A:  CALL   1112
2D7E:  MOVLB  2
2D80:  CLRF   xF1
2D82:  MOVFF  01,2F0
2D86:  MOVLB  0
2D88:  CALL   1008
2D8C:  BSF    FD8.1
2D8E:  MOVFF  2B3,2F6
2D92:  MOVFF  2B2,2F5
2D96:  MOVFF  2B1,2F4
2D9A:  MOVFF  2B0,2F3
2D9E:  MOVFF  03,2FA
2DA2:  MOVFF  02,2F9
2DA6:  MOVFF  01,2F8
2DAA:  MOVFF  00,2F7
2DAE:  CALL   135C
2DB2:  MOVFF  03,28B
2DB6:  MOVFF  02,28A
2DBA:  MOVFF  01,289
2DBE:  MOVFF  00,288
....................     d3=d3*10.0; 
2DC2:  MOVFF  28B,2F1
2DC6:  MOVFF  28A,2F0
2DCA:  MOVFF  289,2EF
2DCE:  MOVFF  288,2EE
2DD2:  MOVLB  2
2DD4:  CLRF   xF5
2DD6:  CLRF   xF4
2DD8:  MOVLW  20
2DDA:  MOVWF  xF3
2DDC:  MOVLW  82
2DDE:  MOVWF  xF2
2DE0:  MOVLB  0
2DE2:  CALL   1BC0
2DE6:  MOVFF  03,28B
2DEA:  MOVFF  02,28A
2DEE:  MOVFF  01,289
2DF2:  MOVFF  00,288
....................     recbuf[2]=(int8)d3; 
2DF6:  MOVFF  28B,2ED
2DFA:  MOVFF  28A,2EC
2DFE:  MOVFF  289,2EB
2E02:  MOVFF  288,2EA
2E06:  CALL   1112
2E0A:  MOVFF  01,2A
....................     recbuf[3]=(int8)Pt; 
2E0E:  MOVFF  263,2ED
2E12:  MOVFF  262,2EC
2E16:  MOVFF  261,2EB
2E1A:  MOVFF  260,2EA
2E1E:  CALL   1112
2E22:  MOVFF  01,2B
....................     recbuf[4]=(int8)Setpoint; 
2E26:  MOVFF  2AB,2ED
2E2A:  MOVFF  2AA,2EC
2E2E:  MOVFF  2A9,2EB
2E32:  MOVFF  2A8,2EA
2E36:  CALL   1112
2E3A:  MOVFF  01,2C
....................     recbuf[5]=(int8)PresionCamara; 
2E3E:  MOVFF  2B7,2ED
2E42:  MOVFF  2B6,2EC
2E46:  MOVFF  2B5,2EB
2E4A:  MOVFF  2B4,2EA
2E4E:  CALL   1112
2E52:  MOVFF  01,2D
....................     d4=Pt-(int8)Pt; 
2E56:  MOVFF  263,2ED
2E5A:  MOVFF  262,2EC
2E5E:  MOVFF  261,2EB
2E62:  MOVFF  260,2EA
2E66:  CALL   1112
2E6A:  MOVLB  2
2E6C:  CLRF   xF1
2E6E:  MOVFF  01,2F0
2E72:  MOVLB  0
2E74:  CALL   1008
2E78:  BSF    FD8.1
2E7A:  MOVFF  263,2F6
2E7E:  MOVFF  262,2F5
2E82:  MOVFF  261,2F4
2E86:  MOVFF  260,2F3
2E8A:  MOVFF  03,2FA
2E8E:  MOVFF  02,2F9
2E92:  MOVFF  01,2F8
2E96:  MOVFF  00,2F7
2E9A:  CALL   135C
2E9E:  MOVFF  03,28F
2EA2:  MOVFF  02,28E
2EA6:  MOVFF  01,28D
2EAA:  MOVFF  00,28C
....................     d4=d4*10.0; 
2EAE:  MOVFF  28F,2F1
2EB2:  MOVFF  28E,2F0
2EB6:  MOVFF  28D,2EF
2EBA:  MOVFF  28C,2EE
2EBE:  MOVLB  2
2EC0:  CLRF   xF5
2EC2:  CLRF   xF4
2EC4:  MOVLW  20
2EC6:  MOVWF  xF3
2EC8:  MOVLW  82
2ECA:  MOVWF  xF2
2ECC:  MOVLB  0
2ECE:  CALL   1BC0
2ED2:  MOVFF  03,28F
2ED6:  MOVFF  02,28E
2EDA:  MOVFF  01,28D
2EDE:  MOVFF  00,28C
....................     recbuf[6]=(int8)d4; 
2EE2:  MOVFF  28F,2ED
2EE6:  MOVFF  28E,2EC
2EEA:  MOVFF  28D,2EB
2EEE:  MOVFF  28C,2EA
2EF2:  CALL   1112
2EF6:  MOVFF  01,2E
....................     recbuf[7]=(int8)NivelTanque; 
2EFA:  MOVFF  224,2F
....................     recbuf[8]=(int8)NivelReservorio; 
2EFE:  MOVFF  223,30
....................     recbuf[9]=(int8)Tpulso; 
2F02:  MOVFF  26B,2ED
2F06:  MOVFF  26A,2EC
2F0A:  MOVFF  269,2EB
2F0E:  MOVFF  268,2EA
2F12:  CALL   1112
2F16:  MOVFF  01,31
....................     d5=Tpulso-(int8)Tpulso; 
2F1A:  MOVFF  26B,2ED
2F1E:  MOVFF  26A,2EC
2F22:  MOVFF  269,2EB
2F26:  MOVFF  268,2EA
2F2A:  CALL   1112
2F2E:  MOVLB  2
2F30:  CLRF   xF1
2F32:  MOVFF  01,2F0
2F36:  MOVLB  0
2F38:  CALL   1008
2F3C:  BSF    FD8.1
2F3E:  MOVFF  26B,2F6
2F42:  MOVFF  26A,2F5
2F46:  MOVFF  269,2F4
2F4A:  MOVFF  268,2F3
2F4E:  MOVFF  03,2FA
2F52:  MOVFF  02,2F9
2F56:  MOVFF  01,2F8
2F5A:  MOVFF  00,2F7
2F5E:  CALL   135C
2F62:  MOVFF  03,293
2F66:  MOVFF  02,292
2F6A:  MOVFF  01,291
2F6E:  MOVFF  00,290
....................     d5=d5*10.0; 
2F72:  MOVFF  293,2F1
2F76:  MOVFF  292,2F0
2F7A:  MOVFF  291,2EF
2F7E:  MOVFF  290,2EE
2F82:  MOVLB  2
2F84:  CLRF   xF5
2F86:  CLRF   xF4
2F88:  MOVLW  20
2F8A:  MOVWF  xF3
2F8C:  MOVLW  82
2F8E:  MOVWF  xF2
2F90:  MOVLB  0
2F92:  CALL   1BC0
2F96:  MOVFF  03,293
2F9A:  MOVFF  02,292
2F9E:  MOVFF  01,291
2FA2:  MOVFF  00,290
....................     recbuf[10]=(int8)d5; 
2FA6:  MOVFF  293,2ED
2FAA:  MOVFF  292,2EC
2FAE:  MOVFF  291,2EB
2FB2:  MOVFF  290,2EA
2FB6:  CALL   1112
2FBA:  MOVFF  01,32
....................     recbuf[11]=(int8)error; 
2FBE:  MOVFF  26F,2ED
2FC2:  MOVFF  26E,2EC
2FC6:  MOVFF  26D,2EB
2FCA:  MOVFF  26C,2EA
2FCE:  CALL   1112
2FD2:  MOVFF  01,33
....................     d6=error-(int8)error; 
2FD6:  MOVFF  26F,2ED
2FDA:  MOVFF  26E,2EC
2FDE:  MOVFF  26D,2EB
2FE2:  MOVFF  26C,2EA
2FE6:  CALL   1112
2FEA:  MOVLB  2
2FEC:  CLRF   xF1
2FEE:  MOVFF  01,2F0
2FF2:  MOVLB  0
2FF4:  CALL   1008
2FF8:  BSF    FD8.1
2FFA:  MOVFF  26F,2F6
2FFE:  MOVFF  26E,2F5
3002:  MOVFF  26D,2F4
3006:  MOVFF  26C,2F3
300A:  MOVFF  03,2FA
300E:  MOVFF  02,2F9
3012:  MOVFF  01,2F8
3016:  MOVFF  00,2F7
301A:  CALL   135C
301E:  MOVFF  03,29F
3022:  MOVFF  02,29E
3026:  MOVFF  01,29D
302A:  MOVFF  00,29C
....................     d6=d6*10.0; 
302E:  MOVFF  29F,2F1
3032:  MOVFF  29E,2F0
3036:  MOVFF  29D,2EF
303A:  MOVFF  29C,2EE
303E:  MOVLB  2
3040:  CLRF   xF5
3042:  CLRF   xF4
3044:  MOVLW  20
3046:  MOVWF  xF3
3048:  MOVLW  82
304A:  MOVWF  xF2
304C:  MOVLB  0
304E:  CALL   1BC0
3052:  MOVFF  03,29F
3056:  MOVFF  02,29E
305A:  MOVFF  01,29D
305E:  MOVFF  00,29C
....................     recbuf[12]=(int8)d6; 
3062:  MOVFF  29F,2ED
3066:  MOVFF  29E,2EC
306A:  MOVFF  29D,2EB
306E:  MOVFF  29C,2EA
3072:  CALL   1112
3076:  MOVFF  01,34
....................      
....................     recbuf[13]=(int8)Aumento; 
307A:  MOVFF  207,2ED
307E:  MOVFF  206,2EC
3082:  MOVFF  205,2EB
3086:  MOVFF  204,2EA
308A:  CALL   1112
308E:  MOVFF  01,35
....................     d7=Aumento-(int8)Aumento; 
3092:  MOVFF  207,2ED
3096:  MOVFF  206,2EC
309A:  MOVFF  205,2EB
309E:  MOVFF  204,2EA
30A2:  CALL   1112
30A6:  MOVLB  2
30A8:  CLRF   xF1
30AA:  MOVFF  01,2F0
30AE:  MOVLB  0
30B0:  CALL   1008
30B4:  BSF    FD8.1
30B6:  MOVFF  207,2F6
30BA:  MOVFF  206,2F5
30BE:  MOVFF  205,2F4
30C2:  MOVFF  204,2F3
30C6:  MOVFF  03,2FA
30CA:  MOVFF  02,2F9
30CE:  MOVFF  01,2F8
30D2:  MOVFF  00,2F7
30D6:  CALL   135C
30DA:  MOVFF  03,2A3
30DE:  MOVFF  02,2A2
30E2:  MOVFF  01,2A1
30E6:  MOVFF  00,2A0
....................     d7=d7*10.0; 
30EA:  MOVFF  2A3,2F1
30EE:  MOVFF  2A2,2F0
30F2:  MOVFF  2A1,2EF
30F6:  MOVFF  2A0,2EE
30FA:  MOVLB  2
30FC:  CLRF   xF5
30FE:  CLRF   xF4
3100:  MOVLW  20
3102:  MOVWF  xF3
3104:  MOVLW  82
3106:  MOVWF  xF2
3108:  MOVLB  0
310A:  CALL   1BC0
310E:  MOVFF  03,2A3
3112:  MOVFF  02,2A2
3116:  MOVFF  01,2A1
311A:  MOVFF  00,2A0
....................     recbuf[14]=(int8)d7; 
311E:  MOVFF  2A3,2ED
3122:  MOVFF  2A2,2EC
3126:  MOVFF  2A1,2EB
312A:  MOVFF  2A0,2EA
312E:  CALL   1112
3132:  MOVFF  01,36
....................      
....................     recbuf[15]=(int8)Ganancia; 
3136:  MOVFF  27F,2ED
313A:  MOVFF  27E,2EC
313E:  MOVFF  27D,2EB
3142:  MOVFF  27C,2EA
3146:  CALL   1112
314A:  MOVFF  01,37
....................     d8=Ganancia-(int8)Ganancia; 
314E:  MOVFF  27F,2ED
3152:  MOVFF  27E,2EC
3156:  MOVFF  27D,2EB
315A:  MOVFF  27C,2EA
315E:  CALL   1112
3162:  MOVLB  2
3164:  CLRF   xF1
3166:  MOVFF  01,2F0
316A:  MOVLB  0
316C:  CALL   1008
3170:  BSF    FD8.1
3172:  MOVFF  27F,2F6
3176:  MOVFF  27E,2F5
317A:  MOVFF  27D,2F4
317E:  MOVFF  27C,2F3
3182:  MOVFF  03,2FA
3186:  MOVFF  02,2F9
318A:  MOVFF  01,2F8
318E:  MOVFF  00,2F7
3192:  CALL   135C
3196:  MOVFF  03,2A7
319A:  MOVFF  02,2A6
319E:  MOVFF  01,2A5
31A2:  MOVFF  00,2A4
....................     d8=d8*10.0; 
31A6:  MOVFF  2A7,2F1
31AA:  MOVFF  2A6,2F0
31AE:  MOVFF  2A5,2EF
31B2:  MOVFF  2A4,2EE
31B6:  MOVLB  2
31B8:  CLRF   xF5
31BA:  CLRF   xF4
31BC:  MOVLW  20
31BE:  MOVWF  xF3
31C0:  MOVLW  82
31C2:  MOVWF  xF2
31C4:  MOVLB  0
31C6:  CALL   1BC0
31CA:  MOVFF  03,2A7
31CE:  MOVFF  02,2A6
31D2:  MOVFF  01,2A5
31D6:  MOVFF  00,2A4
....................     recbuf[16]=(int8)d8; 
31DA:  MOVFF  2A7,2ED
31DE:  MOVFF  2A6,2EC
31E2:  MOVFF  2A5,2EB
31E6:  MOVFF  2A4,2EA
31EA:  CALL   1112
31EE:  MOVFF  01,38
....................     recbuf[17]=(int8)Puerta; 
31F2:  MOVFF  221,39
....................                 
....................     usb_put_packet(1, recbuf, Lenbuf, USB_DTS_TOGGLE); //y enviamos el mismo paquete de tamaño 32bytes del EP1 al PC 
31F6:  MOVLW  01
31F8:  MOVLB  2
31FA:  MOVWF  xEA
31FC:  CLRF   xEC
31FE:  MOVLW  28
3200:  MOVWF  xEB
3202:  CLRF   xEE
3204:  MOVLW  20
3206:  MOVWF  xED
3208:  MOVLW  02
320A:  MOVWF  xEF
320C:  MOVLB  0
320E:  GOTO   1CB6
.................... } 
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------     
....................  
.................... //_--------------------------------------------------------------------------------------------------------------------------------------------------------     
....................     
....................    if(Expulsa==1) 
3212:  MOVLB  2
3214:  BTFSS  x3B.3
3216:  BRA    3252
....................    {    
....................       Temperatura=Leer_Sensor(MediaMovil); 
3218:  MOVFF  257,2EA
321C:  MOVLB  0
321E:  CALL   16F4
3222:  MOVFF  03,2AF
3226:  MOVFF  02,2AE
322A:  MOVFF  01,2AD
322E:  MOVFF  00,2AC
....................       PresionCamara=Leer_Sensor_Presion(5); 
3232:  MOVLW  05
3234:  MOVLB  2
3236:  MOVWF  xEA
3238:  MOVLB  0
323A:  GOTO   1DE0
323E:  MOVFF  03,2B7
3242:  MOVFF  02,2B6
3246:  MOVFF  01,2B5
324A:  MOVFF  00,2B4
....................       Expulsa=0; 
324E:  MOVLB  2
3250:  BCF    x3B.3
....................    }     
....................  
....................    if(tinicio>5400 && tiempo_esterilizacion==0)//tinicio expresado en segundos       
3252:  MOVF   x36,W
3254:  SUBLW  14
3256:  BC    32A0
3258:  XORLW  FF
325A:  BNZ   3262
325C:  MOVF   x35,W
325E:  SUBLW  18
3260:  BC    32A0
3262:  MOVF   x53,F
3264:  BNZ   32A0
....................    { 
....................          if(PresionCamara>2.0) 
3266:  CLRF   xEE
3268:  CLRF   xED
326A:  CLRF   xEC
326C:  MOVLW  80
326E:  MOVWF  xEB
3270:  MOVFF  2B7,2F2
3274:  MOVFF  2B6,2F1
3278:  MOVFF  2B5,2F0
327C:  MOVFF  2B4,2EF
3280:  MOVLB  0
3282:  CALL   1D66
3286:  BNC   328C
....................          { 
....................             EV_Desfogue_on; 
3288:  BSF    F8A.1
328A:  BCF    F93.1
....................          } 
....................          Alarma=1; 
328C:  MOVLW  01
328E:  MOVLB  2
3290:  MOVWF  x1E
....................          EV_in_Agua_off; 
3292:  BCF    F8A.4
3294:  BCF    F93.4
....................          EV_Agua_off; 
3296:  BCF    F8A.2
3298:  BCF    F93.2
....................          Resistencia_off; 
329A:  BCF    F8A.0
329C:  BCF    F93.0
....................    } 
....................    else 
329E:  BRA    3472
....................    {       
....................       if(EVDesfogue<1 && tiempo_esterilizacion==1 && (Temperatura<100.0 || Temperatura>145.0)) 
32A0:  MOVF   x16,F
32A2:  BNZ   330A
32A4:  DECFSZ x53,W
32A6:  BRA    330A
32A8:  MOVFF  2AF,2EE
32AC:  MOVFF  2AE,2ED
32B0:  MOVFF  2AD,2EC
32B4:  MOVFF  2AC,2EB
32B8:  CLRF   xF2
32BA:  CLRF   xF1
32BC:  MOVLW  48
32BE:  MOVWF  xF0
32C0:  MOVLW  85
32C2:  MOVWF  xEF
32C4:  MOVLB  0
32C6:  CALL   1D66
32CA:  BC    32F8
32CC:  MOVLB  2
32CE:  CLRF   xEE
32D0:  CLRF   xED
32D2:  MOVLW  11
32D4:  MOVWF  xEC
32D6:  MOVLW  86
32D8:  MOVWF  xEB
32DA:  MOVFF  2AF,2F2
32DE:  MOVFF  2AE,2F1
32E2:  MOVFF  2AD,2F0
32E6:  MOVFF  2AC,2EF
32EA:  MOVLB  0
32EC:  CALL   1D66
32F0:  BTFSC  FD8.0
32F2:  BRA    32F8
32F4:  MOVLB  2
32F6:  BRA    330A
....................       { 
....................          Alarma=2; 
32F8:  MOVLW  02
32FA:  MOVLB  2
32FC:  MOVWF  x1E
....................          EV_in_Agua_off; 
32FE:  BCF    F8A.4
3300:  BCF    F93.4
....................          EV_Agua_off; 
3302:  BCF    F8A.2
3304:  BCF    F93.2
....................          Resistencia_off; 
3306:  BCF    F8A.0
3308:  BCF    F93.0
....................       } 
....................        
....................       if(tagua>50) // Si se el ingreso de agua al tanque dura mas de 12 minutos se activa la alarma por falta de agua. 
330A:  MOVF   x38,F
330C:  BNZ   3314
330E:  MOVF   x37,W
3310:  SUBLW  32
3312:  BC    3324
....................       { 
....................          AlarmaAgua=1;  
3314:  MOVLW  01
3316:  MOVWF  x1F
....................          EV_in_Agua_off; 
3318:  BCF    F8A.4
331A:  BCF    F93.4
....................          EV_Agua_off; 
331C:  BCF    F8A.2
331E:  BCF    F93.2
....................          Resistencia_off; 
3320:  BCF    F8A.0
3322:  BCF    F93.0
....................       } 
....................        
....................       if(Control==1 && !DOOR && !STOP && AlarmaAgua==0 && Alarma==0) // Si esta en condiciones normales para ejecutar el control. 
3324:  DECFSZ x1D,W
3326:  BRA    3362
3328:  BSF    F95.5
332A:  BTFSS  F83.5
332C:  BRA    3362
332E:  BSF    F95.4
3330:  BTFSS  F83.4
3332:  BRA    3362
3334:  MOVF   x1F,F
3336:  BNZ   3362
3338:  MOVF   x1E,F
333A:  BNZ   3362
....................       { 
....................          if(!TERM) 
333C:  BSF    F95.6
333E:  BTFSS  F83.6
3340:  BRA    334C
....................          { 
....................             Controla(); 
3342:  MOVLB  0
3344:  GOTO   1FD4
....................          } 
....................          else 
3348:  BRA    3350
334A:  MOVLB  2
....................          { 
....................             Resistencia_off; 
334C:  BCF    F8A.0
334E:  BCF    F93.0
....................          } 
....................           
....................          if(CamaraOUT==1) 
3350:  MOVLB  2
3352:  BTFSS  x08.5
3354:  BRA    335C
....................          { 
....................             EV_Desfogue_on; 
3356:  BSF    F8A.1
3358:  BCF    F93.1
....................          } 
....................          else 
335A:  BRA    3360
....................          { 
....................             EV_Desfogue_off;  
335C:  BCF    F8A.1
335E:  BCF    F93.1
....................          } 
....................       } 
....................       else 
3360:  BRA    3366
....................       { 
....................          Resistencia_off; 
3362:  BCF    F8A.0
3364:  BCF    F93.0
....................       } 
....................              
.................... // Manejo de llenado de Autoclave con Agua        
....................       if(EVAgua!=0 && flag_agua==0) 
3366:  MOVF   x17,F
3368:  BZ    33DA
336A:  BTFSC  x08.2
336C:  BRA    33DA
....................       { 
....................          // Nueva prueba para carga de agua 
....................          if(!LEVELT && !STOP) 
336E:  BSF    F95.0
3370:  BTFSS  F83.0
3372:  BRA    33B8
3374:  BSF    F95.4
3376:  BTFSS  F83.4
3378:  BRA    33B8
....................          { 
....................             flag_reservorio=0;    
337A:  BCF    x08.7
....................             treservorio=0; 
337C:  CLRF   x3A
337E:  CLRF   x39
....................             EV_Agua_on; 
3380:  BSF    F8A.2
3382:  BCF    F93.2
....................             tiempo_esterilizacion=0; 
3384:  CLRF   x53
....................             flag_agua=0;flag_agua2=0; 
3386:  BCF    x08.2
3388:  BCF    x08.4
....................             delay_ms(600); 
338A:  MOVLW  03
338C:  MOVWF  xEA
338E:  MOVLW  C8
3390:  MOVWF  xF0
3392:  MOVLB  0
3394:  CALL   0FDE
3398:  MOVLB  2
339A:  DECFSZ xEA,F
339C:  BRA    338E
....................             EV_Agua_off; 
339E:  BCF    F8A.2
33A0:  BCF    F93.2
....................             delay_ms(1200); 
33A2:  MOVLW  05
33A4:  MOVWF  xEA
33A6:  MOVLW  F0
33A8:  MOVWF  xF0
33AA:  MOVLB  0
33AC:  CALL   0FDE
33B0:  MOVLB  2
33B2:  DECFSZ xEA,F
33B4:  BRA    33A6
....................          } 
....................          else 
33B6:  BRA    33DA
....................          { 
....................             if(treservorio>=800) 
33B8:  MOVF   x3A,W
33BA:  SUBLW  02
33BC:  BC    33D8
33BE:  XORLW  FF
33C0:  BNZ   33C8
33C2:  MOVF   x39,W
33C4:  SUBLW  1F
33C6:  BC    33D8
....................             { 
....................                EV_Agua_off; 
33C8:  BCF    F8A.2
33CA:  BCF    F93.2
....................                flag_reservorio=0;    
33CC:  BCF    x08.7
....................                flag_agua2=1;p=3; 
33CE:  BSF    x08.4
33D0:  MOVLW  03
33D2:  MOVWF  x56
....................                flag_agua=1; 
33D4:  BSF    x08.2
....................             } 
....................             else 
33D6:  BRA    33DA
....................             { 
....................                flag_reservorio=1;    
33D8:  BSF    x08.7
....................             } 
....................          }       
....................           
....................          /*if(!LEVELT && !STOP) 
....................          { 
....................             flag_reservorio=0;    
....................             treservorio=0; 
....................             EV_Agua_on; 
....................             tiempo_esterilizacion=0; 
....................             flag_agua=0;flag_agua2=0; 
....................          } 
....................          else 
....................          { 
....................             if(treservorio>=300) 
....................             { 
....................                EV_Agua_off; 
....................                flag_reservorio=0;    
....................                flag_agua2=1;p=3; 
....................                flag_agua=1; 
....................             } 
....................             else 
....................             { 
....................                flag_reservorio=1;    
....................             } 
....................          }*/ 
....................        
....................          /*if(NivelTanque==1) 
....................          { 
....................             if(flag_agua==0) 
....................             { 
....................                delay_ms(1000); 
....................              
....................                if(!input(PIN_D0)) 
....................                {    
....................                   flag_agua=1; 
....................                   EV_Agua_off; 
....................                   if(flag_agua2==0) 
....................                   { 
....................                      flag_agua2=1;p=3; 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                EV_Agua_off; 
....................             } 
....................          } 
....................          else 
....................          { 
....................             if(flag_agua==0) 
....................             { 
....................                EV_Agua_on;tiempo_esterilizacion=0; 
....................             } 
....................          }*/ 
....................       } 
.................... // Fin de Manejo de llenado de Autoclave con Agua 
....................        
.................... //       
....................       if(Temperatura>=(Setpoint-1.0)&&p==3)// Si activa alarma de esterilización. Inicia tiempo de esterilización. 
33DA:  BSF    FD8.1
33DC:  MOVFF  2AB,2F6
33E0:  MOVFF  2AA,2F5
33E4:  MOVFF  2A9,2F4
33E8:  MOVFF  2A8,2F3
33EC:  CLRF   xFA
33EE:  CLRF   xF9
33F0:  CLRF   xF8
33F2:  MOVLW  7F
33F4:  MOVWF  xF7
33F6:  MOVLB  0
33F8:  CALL   135C
33FC:  MOVFF  03,2EE
3400:  MOVFF  02,2ED
3404:  MOVFF  01,2EC
3408:  MOVFF  00,2EB
340C:  MOVFF  2AF,2F2
3410:  MOVFF  2AE,2F1
3414:  MOVFF  2AD,2F0
3418:  MOVFF  2AC,2EF
341C:  CALL   1D66
3420:  BC    3424
3422:  BNZ   3438
3424:  MOVLB  2
3426:  MOVF   x56,W
3428:  SUBLW  03
342A:  BTFSC  FD8.2
342C:  BRA    3432
342E:  MOVLB  0
3430:  BRA    3438
....................       { 
....................          tiempo_esterilizacion=1;     
3432:  MOVLW  01
3434:  MOVWF  x53
....................          p=1; 
3436:  MOVWF  x56
....................          //Ganancia=Ganancia2; 
....................       }         
....................        
....................       if(EVDesfogue==1 ) 
3438:  MOVLB  2
343A:  DECFSZ x16,W
343C:  BRA    344A
....................       { 
....................          EV_Desfogue_on; 
343E:  BSF    F8A.1
3440:  BCF    F93.1
....................          EV_Agua_off; 
3442:  BCF    F8A.2
3444:  BCF    F93.2
....................          Resistencia_off; 
3446:  BCF    F8A.0
3448:  BCF    F93.0
....................       }  
....................        
....................       if(EVDesfogue==3 && !STOP ) 
344A:  MOVF   x16,W
344C:  SUBLW  03
344E:  BNZ   3472
3450:  BSF    F95.4
3452:  BTFSS  F83.4
3454:  BRA    3472
....................       { 
....................          if(Presostato<2) 
3456:  MOVF   x25,W
3458:  SUBLW  01
345A:  BNC   3462
....................          { 
....................             EV_Desfogue_off; 
345C:  BCF    F8A.1
345E:  BCF    F93.1
....................          } 
....................          else 
3460:  BRA    3466
....................          { 
....................             EV_Desfogue_on; 
3462:  BSF    F8A.1
3464:  BCF    F93.1
....................          } 
....................          Resistencia_off; 
3466:  BCF    F8A.0
3468:  BCF    F93.0
....................          if(Control==3) 
346A:  MOVF   x1D,W
346C:  SUBLW  03
346E:  BNZ   3472
....................          { 
....................             reset_cpu(); 
3470:  RESET
....................          } 
....................       } 
....................    }     
.................... //_-------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................   
....................       Puerta=input(PIN_D5); 
3472:  BSF    F95.5
3474:  CLRF   x21
3476:  BTFSC  F83.5
3478:  INCF   x21,F
....................       Parada=input(PIN_D4); 
347A:  BSF    F95.4
347C:  CLRF   x22
347E:  BTFSC  F83.4
3480:  INCF   x22,F
....................       NivelReservorio=!input(PIN_D1); 
3482:  BSF    F95.1
3484:  CLRF   x23
3486:  BTFSS  F83.1
3488:  INCF   x23,F
....................       NivelTanque=!input(PIN_D0); 
348A:  BSF    F95.0
348C:  CLRF   x24
348E:  BTFSS  F83.0
3490:  INCF   x24,F
....................       //Temperatura=Leer_Sensor(10); 
....................       d3=Temperatura-(int8)Temperatura; 
3492:  MOVFF  2AF,2ED
3496:  MOVFF  2AE,2EC
349A:  MOVFF  2AD,2EB
349E:  MOVFF  2AC,2EA
34A2:  MOVLB  0
34A4:  CALL   1112
34A8:  MOVLB  2
34AA:  CLRF   xF1
34AC:  MOVFF  01,2F0
34B0:  MOVLB  0
34B2:  CALL   1008
34B6:  BSF    FD8.1
34B8:  MOVFF  2AF,2F6
34BC:  MOVFF  2AE,2F5
34C0:  MOVFF  2AD,2F4
34C4:  MOVFF  2AC,2F3
34C8:  MOVFF  03,2FA
34CC:  MOVFF  02,2F9
34D0:  MOVFF  01,2F8
34D4:  MOVFF  00,2F7
34D8:  CALL   135C
34DC:  MOVFF  03,28B
34E0:  MOVFF  02,28A
34E4:  MOVFF  01,289
34E8:  MOVFF  00,288
....................       d3=d3*10.0; 
34EC:  MOVFF  28B,2F1
34F0:  MOVFF  28A,2F0
34F4:  MOVFF  289,2EF
34F8:  MOVFF  288,2EE
34FC:  MOVLB  2
34FE:  CLRF   xF5
3500:  CLRF   xF4
3502:  MOVLW  20
3504:  MOVWF  xF3
3506:  MOVLW  82
3508:  MOVWF  xF2
350A:  MOVLB  0
350C:  CALL   1BC0
3510:  MOVFF  03,28B
3514:  MOVFF  02,28A
3518:  MOVFF  01,289
351C:  MOVFF  00,288
....................       Presostato=(int8)PresionCamara; 
3520:  MOVFF  2B7,2ED
3524:  MOVFF  2B6,2EC
3528:  MOVFF  2B5,2EB
352C:  MOVFF  2B4,2EA
3530:  CALL   1112
3534:  MOVFF  01,225
....................       if(CadenaRecibida==1) 
3538:  MOVLB  2
353A:  BTFSS  x3B.1
353C:  BRA    354C
....................       { 
....................          Determina(); 
353E:  MOVLB  0
3540:  GOTO   234A
....................          EnviarCodigo(); 
3544:  CALL   1158
....................          CadenaRecibida=0; 
3548:  MOVLB  2
354A:  BCF    x3B.1
....................       }  
....................    } 
354C:  GOTO   2A90
.................... } 
3550:  SLEEP 

Configuration Fuses:
   Word  1: CE20   IESO FCMEN HSPLL PLL1 CPUDIV1 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 0700   PBADEN CCP2C1 NOMCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
